<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Royal Cash - League Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="config.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-main: #F5F5DC;
            --gold: #D4AF37;
            --green: #2ecc71;
            --red: #e74c3c;
            --gray: #888;
            --accent-blue: #3498db;
            --bit-blue: #0066CC;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }
        
        /* Ensure all text is visible */
        h1, h2, h3, h4, h5, h6 {
            color: #fff;
        }
        
        .card {
            color: #fff;
        }

        /* --- Navigation & Header --- */
        .app-header {
            background: #000;
            padding: 15px;
            text-align: center;
            border-bottom: 2px solid var(--gold);
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }
        
        /* Center logo in header */
        .app-logo {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .app-logo {
            max-height: 50px;
            width: auto;
            display: block;
            margin: 0 auto;
        }

        .back-btn {
            background: none;
            border: none;
            color: var(--gold);
            font-size: 1.2rem;
            cursor: pointer;
            visibility: hidden;
        }
        
        /* Flip arrow direction for English (LTR) */
        html[dir="ltr"] .back-btn {
            transform: scaleX(-1);
        }

        .user-menu {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .user-name {
            color: var(--gold);
            font-size: 0.9rem;
        }

        .logout-btn {
            background: none;
            border: 1px solid var(--red);
            color: var(--red);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
            padding: 15px;
        }

        .hidden { display: none !important; }

        /* --- Buttons --- */
        .btn-gold {
            background: var(--gold);
            color: #000;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-size: 1rem;
        }
        .btn-outline {
            background: transparent;
            border: 1px solid var(--gold);
            color: var(--gold);
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }
        .btn-food { background: #e67e22; color: #fff; border:none; }

        /* --- Pay with Bit Button --- */
        .btn-bit {
            background: var(--bit-blue);
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 8px;
            font-size: 0.9rem;
            transition: background 0.2s;
        }
        .btn-bit:hover {
            background: #0052a3;
        }

        /* --- Cards --- */
        .card {
            background: var(--card-bg);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }
        .card-title { font-size: 1.2rem; font-weight: bold; color: #fff; margin-bottom: 5px; }
        
        /* --- Player Row in Table --- */
        .player-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #252525;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--gold);
            transition: transform 0.5s ease-in-out, opacity 0.3s ease-in-out;
            position: relative;
        }
        .rebuy-btn {
            width: 30px; height: 30px;
            border-radius: 50%;
            background: none;
            border: 1px solid var(--gold);
            color: var(--gold);
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
        }
        .rebuy-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* --- Leaderboard Table --- */
        .league-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .league-table th { text-align: right; color: var(--gray); padding: 8px; border-bottom: 1px solid #444; }
        .league-table td { padding: 10px 8px; border-bottom: 1px solid #333; }
        .profit { color: var(--green); }
        .loss { color: var(--red); }

        /* --- Hall of Fame --- */
        .hall-of-fame {
            margin-top: 20px;
        }
        .hof-stat {
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 3px solid var(--gold);
        }
        .hof-stat-title {
            font-size: 0.9rem;
            color: var(--gray);
            margin-bottom: 5px;
        }
        .hof-stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--gold);
        }

        /* --- Auth Views --- */
        .auth-container {
            max-width: 400px;
            margin: 50px auto;
            padding: 20px;
        }
        
        /* Auth form text colors */
        #auth-form-login, #auth-form-signup {
            color: #fff;
        }
        
        #auth-form-login h3, #auth-form-signup h3 {
            color: #fff;
            margin-bottom: 15px;
        }
        .auth-tabs {
            display: flex;
            margin-bottom: 20px;
        }
        .auth-tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            background: #222;
            border: 1px solid #444;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
        }
        .auth-tab.active {
            background: var(--gold);
            color: #000;
            font-weight: bold;
        }

        /* --- Settlement Transfer Row --- */
        .transfer-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #252525;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .transfer-info {
            flex: 1;
        }

        /* --- Toast Notification --- */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--gold);
            color: #000;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* --- Modals --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 100;
            display: flex; justify-content: center; align-items: center;
        }
        .modal-box {
            background: #222;
            padding: 20px;
            width: 90%; max-width: 380px;
            border-radius: 12px;
            border: 1px solid var(--gold);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        input, select {
            width: 100%; padding: 10px; margin: 8px 0;
            background: #000; border: 1px solid #444; color: #fff;
            border-radius: 5px;
            box-sizing: border-box;
            text-align: right;
            direction: rtl;
        }
        
        /* Fix for tel input in Hebrew - ensure RTL */
        input[type="tel"] {
            direction: rtl;
            text-align: right;
        }
        
        /* Placeholder text color - gray for all inputs */
        input::placeholder,
        input::-webkit-input-placeholder,
        input::-moz-placeholder,
        input:-ms-input-placeholder {
            color: #888 !important;
            opacity: 1 !important;
        }
        
        /* Specific selectors for auth form inputs */
        #loginEmail::placeholder,
        #loginEmail::-webkit-input-placeholder,
        #loginEmail::-moz-placeholder,
        #loginEmail:-ms-input-placeholder,
        #loginPassword::placeholder,
        #loginPassword::-webkit-input-placeholder,
        #loginPassword::-moz-placeholder,
        #loginPassword:-ms-input-placeholder,
        #signupEmail::placeholder,
        #signupEmail::-webkit-input-placeholder,
        #signupEmail::-moz-placeholder,
        #signupEmail:-ms-input-placeholder,
        #signupPassword::placeholder,
        #signupPassword::-webkit-input-placeholder,
        #signupPassword::-moz-placeholder,
        #signupPassword:-ms-input-placeholder,
        #signupUsername::placeholder,
        #signupUsername::-webkit-input-placeholder,
        #signupUsername::-moz-placeholder,
        #signupUsername:-ms-input-placeholder,
        #signupPhone::placeholder,
        #signupPhone::-webkit-input-placeholder,
        #signupPhone::-moz-placeholder,
        #signupPhone:-ms-input-placeholder {
            color: #aaa !important;
            opacity: 1 !important;
        }
        
        /* Specific classes for dynamic inputs */
        .cashout-input::placeholder,
        .cashout-input::-webkit-input-placeholder,
        .cashout-input::-moz-placeholder,
        .cashout-input:-ms-input-placeholder {
            color: #888 !important;
            opacity: 1 !important;
        }
        
        .indiv-amount::placeholder,
        .indiv-amount::-webkit-input-placeholder,
        .indiv-amount::-moz-placeholder,
        .indiv-amount:-ms-input-placeholder {
            color: #888 !important;
            opacity: 1 !important;
        }
        
        /* Auth form container inputs */
        #auth-form-login input::placeholder,
        #auth-form-login input::-webkit-input-placeholder,
        #auth-form-login input::-moz-placeholder,
        #auth-form-login input:-ms-input-placeholder,
        #auth-form-signup input::placeholder,
        #auth-form-signup input::-webkit-input-placeholder,
        #auth-form-signup input::-moz-placeholder,
        #auth-form-signup input:-ms-input-placeholder {
            color: #aaa !important;
            opacity: 1 !important;
        }

        /* Toggle Switch for Food */
        .toggle-container {
            display: flex;
            background: #000;
            border-radius: 20px;
            margin: 10px 0;
            border: 1px solid #444;
            overflow: hidden;
        }
        .toggle-btn {
            flex: 1;
            padding: 8px;
            text-align: center;
            cursor: pointer;
            font-size: 0.9rem;
            color: #888;
        }
        .toggle-btn.active {
            background: var(--gold);
            color: #000;
            font-weight: bold;
        }

        .error-message {
            color: var(--red);
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .loading {
            text-align: center;
            color: var(--gray);
            padding: 20px;
        }

        /* --- Game Logs --- */
        .game-log-item {
            padding: 8px;
            border-bottom: 1px solid #333;
            font-size: 0.9rem;
            color: var(--text-main);
        }
        .game-log-item:last-child {
            border-bottom: none;
        }
        .game-log-time {
            color: var(--gray);
            font-size: 0.75rem;
            margin-right: 8px;
        }

    </style>
</head>
<body>

    <header class="app-header">
        <!-- Left side: Back button and Language toggle -->
        <div style="display: flex; align-items: center; gap: 10px; flex: 1;">
            <button id="backBtn" class="back-btn" onclick="goBack()">â”</button>
            <!-- Language Toggle Button - Left side -->
            <div style="position: relative; margin-left: 5px;">
                <button id="languageToggleBtn" onclick="toggleAuthLanguageMenu()" style="background: transparent; border: none; font-size: 1.3rem; cursor: pointer; padding: 5px 8px; transition: transform 0.2s, filter 0.2s; display: flex; align-items: center; justify-content: center; filter: brightness(0) saturate(100%) invert(77%) sepia(50%) saturate(2000%) hue-rotate(5deg) brightness(0.9) contrast(1.1);" onmouseover="this.style.transform='scale(1.15)'; this.style.filter='brightness(0) saturate(100%) invert(77%) sepia(50%) saturate(2000%) hue-rotate(5deg) brightness(1.1) contrast(1.1)'" onmouseout="this.style.transform='scale(1)'; this.style.filter='brightness(0) saturate(100%) invert(77%) sepia(50%) saturate(2000%) hue-rotate(5deg) brightness(0.9) contrast(1.1)'" title="Change Language">
                    ğŸŒ
                </button>
                <!-- Language Menu Dropdown - Compact size, centered under button -->
                <div id="authLanguageMenu" class="language-menu" style="display: none; position: absolute; top: 40px; left: 50%; transform: translateX(-50%); background: var(--card-bg); border: 1px solid var(--gold); border-radius: 6px; overflow: hidden; z-index: 1000; min-width: 80px; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">
                    <div onclick="selectAuthLanguage('he')" style="padding: 6px 12px; cursor: pointer; color: #fff; font-size: 0.85rem; transition: background 0.2s;" onmouseover="this.style.background='var(--gold)'; this.style.color='#000'" onmouseout="this.style.background=''; this.style.color='#fff'">×¢×‘×¨×™×ª</div>
                    <div onclick="selectAuthLanguage('en')" style="padding: 6px 12px; cursor: pointer; color: #fff; font-size: 0.85rem; border-top: 1px solid #444; transition: background 0.2s;" onmouseover="this.style.background='var(--gold)'; this.style.color='#000'" onmouseout="this.style.background=''; this.style.color='#fff'">English</div>
                </div>
            </div>
        </div>
        <!-- Center: Logo -->
        <img src="logo.png" class="app-logo" alt="Royal Cash">
        <!-- Right side: User menu -->
        <div style="display: flex; align-items: center; gap: 10px; flex: 1; justify-content: flex-end;">
            <div class="user-menu" id="userMenu" style="display:none;">
                <span class="user-name" id="userName"></span>
                <button class="logout-btn" id="btnLogout" onclick="handleLogout()">×”×ª× ×ª×§</button>
            </div>
        </div>
    </header>

    <div class="container">

        <!-- Auth View -->
        <!-- Loading View -->
        <div id="view-loading">
            <div style="text-align:center; padding:50px;">
                <div class="loading" style="font-size:1.2rem; color:var(--gold);" id="loadingText">×˜×•×¢×Ÿ...</div>
            </div>
        </div>

        <div id="view-auth" class="hidden">
            <div class="auth-container">
                <div class="auth-tabs">
                    <div class="auth-tab active" id="tab-login" onclick="switchAuthTab('login')"><span id="tabLoginText">×”×ª×—×‘×¨×•×ª</span></div>
                    <div class="auth-tab" id="tab-signup" onclick="switchAuthTab('signup')"><span id="tabSignupText">×”×¨×©××”</span></div>
                </div>
                <div class="card">
                    <div id="auth-form-login">
                        <h3 id="loginTitle">×”×ª×—×‘×¨×•×ª</h3>
                        <input type="email" id="loginEmail" placeholder="">
                        <input type="password" id="loginPassword" placeholder="">
                        <div id="loginError" class="error-message hidden"></div>
                        <button class="btn-gold" id="btnLogin" onclick="handleLogin()">×”×ª×—×‘×¨</button>
                    </div>
                    <div id="auth-form-signup" class="hidden">
                        <h3 id="signupTitle">×”×¨×©××”</h3>
                        <input type="text" id="signupUsername" placeholder="">
                        <input type="email" id="signupEmail" placeholder="">
                        <input type="tel" id="signupPhone" placeholder="" pattern="[0-9]{10}">
                        <input type="password" id="signupPassword" placeholder="">
                        <div id="signupError" class="error-message hidden"></div>
                        <button class="btn-gold" id="btnSignup" onclick="handleSignup()">×”×™×¨×©×</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main App Views -->
        <div id="view-lobby" class="hidden">
            <!-- Lobby Tabs -->
            <div class="auth-tabs" style="margin-bottom: 20px;">
                <div class="auth-tab active" id="tab-active-games" onclick="switchLobbyTab('active')">×©×•×œ×—× ×•×ª ×¤×¢×™×œ×™×</div>
                <div class="auth-tab" id="tab-history" onclick="switchLobbyTab('history')">×”×™×¡×˜×•×¨×™×”</div>
            </div>

            <div id="lobby-active-view">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                    <h3 style="margin:0; border-bottom: 1px solid #333; padding-bottom: 10px; flex:1;" id="activeTablesTitle">×©×•×œ×—× ×•×ª ×¤×¢×™×œ×™×</h3>
                    <button class="btn-outline" onclick="showMyStats()" style="width:auto; margin:0 0 0 10px; padding:8px 15px;" id="btnMyStats">
                        <span id="myStatsBtnText">×”× ×ª×•× ×™× ×©×œ×™</span> <span style="margin-right: 5px;">ğŸ“Š</span>
                    </button>
                </div>
                <div id="tablesListContainer" class="loading"><span id="loadingTablesText">×˜×•×¢×Ÿ...</span></div>
            <button class="btn-gold" onclick="openModal('modal-create')" id="btnCreateTable">×¤×ª×— ×©×•×œ×—×Ÿ ×—×“×© <span style="margin-right: 5px;">+</span></button>
        </div>

            <div id="lobby-history-view" class="hidden">
                <h3 id="deletedTablesTitle" style="margin:0; border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 15px;"><span style="margin-right: 5px;">ğŸ“œ</span></h3>
                <div id="deletedTablesContainer" class="loading"></div>
            </div>
        </div>

        <!-- My Stats View -->
        <div id="view-my-stats" class="hidden">
            <h2 style="text-align:center; color:var(--gold); margin-bottom:20px;"><span id="myStatsPageTitle">×”× ×ª×•× ×™× ×©×œ×™</span> <span style="margin-right: 5px;">ğŸ“Š</span></h2>
            <div class="card">
                <div id="myStatsContent" class="loading"><span id="loadingStatsText">×˜×•×¢×Ÿ × ×ª×•× ×™×...</span></div>
            </div>
        </div>

        <!-- Game Summary View -->
        <div id="view-summary" class="hidden">
            <h2 style="text-align:center; color:var(--gold); margin-bottom:10px;"><span id="summaryTitle">×¡×™×›×•× ××©×—×§</span> <span style="margin-right: 5px;">ğŸ†</span></h2>
            <h3 id="summaryTableName" style="text-align:center; margin:0 0 20px 0; color:var(--gray);"></h3>
            
            <div class="card">
                <h3 style="color:var(--gold); margin-top:0;" id="finalResultsTitle">×ª×•×¦××•×ª ×¡×•×¤×™×•×ª</h3>
                <div id="summaryList"></div>
            </div>

            <button class="btn-outline" onclick="showLobby()" style="margin-top:20px;" id="btnBackToLobby">×—×–×¨×” ×œ×œ×•×‘×™</button>
        </div>

        <div id="view-table" class="hidden">
            <div class="card" style="text-align:center; border-color:var(--gold);">
                <h2 id="activeTableName" style="margin:0; color:var(--gold)"></h2>
                <div style="display:flex; justify-content:space-around; margin-top:10px;">
                    <div><small style="color:var(--gray)" id="entryLabel">×›× ×™×¡×”</small><div id="activeBuyIn" style="font-weight:bold"></div></div>
                    <div><small style="color:var(--gray)" id="potLabel">×§×•×¤×”</small><div id="activePot" style="font-weight:bold"></div></div>
                </div>
            </div>

            <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
                <span id="playersLabel" style="color:#888;">×©×—×§× ×™×</span>
                <button onclick="openModal('modal-add-player')" style="background:none; border:none; color:var(--gold);" id="btnAddPlayer">+ <span id="addPlayerText">×”×•×¡×£</span></button>
            </div>
            
            <div id="activePlayersList"></div>

            <!-- Game Logs Section -->
            <div style="margin-top: 20px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    <span id="gameActivityLabel" style="color:#888;">×¤×¢×™×œ×•×ª ×”××©×—×§ <span style="margin-right: 5px;">ğŸ“</span></span>
                    <button onclick="toggleGameLogs()" style="background:none; border:none; color:var(--gold); font-size:0.9rem;" id="btnToggleLogs">×”×¦×’/×”×¡×ª×¨</button>
                </div>
                <div id="gameLogsContainer" class="card hidden" style="max-height:200px; overflow-y:auto; background:#1a1a1a;">
                    <div id="gameLogsList" class="loading"><span id="loadingLogsText">×˜×•×¢×Ÿ ×œ×•×’×™×...</span></div>
                </div>
            </div>

            <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:20px;">
                <button id="btnWeWereHungry" class="btn-gold btn-food" onclick="openFoodModal()"><span style="margin-right: 5px;">ğŸ”ğŸ•</span></button>
                <button id="btnShareLink" class="btn-outline" onclick="openShareModal()"><span style="margin-right: 5px;">ğŸ”—</span></button>
                <button id="btnSettle" class="btn-gold" style="grid-column:span 2;" onclick="startSettle()"><span style="margin-right: 5px;">ğŸ’°</span></button>
            </div>

            <!-- Delete Table Button (only for owner) -->
            <button id="btnDeleteTable" class="btn-outline" onclick="deleteTableFromView()" style="margin-top: 20px; width: 100%; background: var(--red); color: #fff; border-color: var(--red); display: none;">
                <span id="deleteTableText"></span> <span style="margin-right: 5px;">ğŸ—‘ï¸</span>
            </button>

            <!-- Hall of Fame Section -->
            <div class="hall-of-fame">
                <button id="btnHallOfFame" class="btn-outline" onclick="toggleHallOfFame()" style="margin-top: 20px;">
                    <span id="hallOfFameBtnText"></span> <span style="margin-right: 5px;">ğŸ†</span>
                </button>
                <div id="hallOfFameContent" class="hidden">
                    <div class="card" style="margin-top: 15px;">
                        <h3 style="text-align:center; color:var(--gold); margin-top:0;"><span id="hallOfFameTitle">×”×™×›×œ ×”×ª×”×™×œ×”</span> <span style="margin-right: 5px;">ğŸ†</span></h3>
                        
                        <div class="hof-stat">
                            <div class="hof-stat-title"><span id="sharkTitle">×”×›×¨×™×© (×”×¨×•×•×— ×”×’×“×•×œ ×‘×™×•×ª×¨ ×‘××©×—×§ ×‘×•×“×“)</span> <span style="margin-right: 5px;">ğŸ¦ˆ</span></div>
                            <div class="hof-stat-value" id="hofShark">-</div>
                        </div>

                        <div class="hof-stat">
                            <div class="hof-stat-title"><span id="loserTitle">×”××¤×¡×™×“ (×”×”×¤×¡×“ ×”×’×“×•×œ ×‘×™×•×ª×¨ ×‘××©×—×§ ×‘×•×“×“)</span> <span style="margin-right: 5px;">ğŸ‘</span></div>
                            <div class="hof-stat-value" id="hofLoser">-</div>
                        </div>

                        <h4 style="color:var(--gray); margin-top:20px; margin-bottom:10px;" id="leagueTableTitle">×˜×‘×œ×ª ×œ×™×’×” (×©×•×œ×—×Ÿ ×–×” ×‘×œ×‘×“)</h4>
                        <table class="league-table" id="tableLeagueTable">
                            <thead>
                                <tr>
                                    <th id="thPlayer">×©×—×§×Ÿ</th>
                                    <th id="thGames">××©×—×§×™×</th>
                                    <th id="thProfitLoss">×¨×•×•×—/×”×¤×¡×“</th>
                                </tr>
                            </thead>
                            <tbody id="tableLeagueTableBody">
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div id="view-settle" class="hidden">
            <h2 style="text-align:center; color:var(--gold); margin-bottom:20px;"><span id="settlePageTitle">×¡×™×•× ×—×©×‘×•×Ÿ</span> <span style="margin-right: 5px;">ğŸ’°</span></h2>
            
            <div class="card">
                <h3 style="color:var(--gray); margin-top:0;" id="howMuchCashTitle">×›××” ×›×¡×£ ×™×© ×œ×›×œ ××—×“ ×‘×™×“?</h3>
                <div id="settleInputs"></div>
                
                <button class="btn-gold" onclick="calcResult()" style="margin-top:20px;" id="btnCalculate">×—×©×‘ ×ª×•×¦××•×ª</button>
            </div>
            
            <div id="settleResults" class="card hidden" style="margin-top:20px;"></div>
            
            <div style="margin-top:20px; text-align:center;">
                <button class="btn-gold hidden" id="btnFinishGame" onclick="saveAndExit()">ğŸ  <span id="updateAndExitText">×¢×“×›×Ÿ × ×ª×•× ×™× ×•×¦× ×œ×œ×•×‘×™</span></button>
            </div>
        </div>

    </div>

    <div id="modal-create" class="modal-overlay hidden">
        <div class="modal-box">
            <h3 id="newTableTitle">×©×•×œ×—×Ÿ ×—×“×©</h3>
            <input type="text" id="newTableName" placeholder="">
            <input type="number" id="newTableBuyIn" placeholder="">
            <button class="btn-gold" onclick="createNewTable()" id="btnCreate">×¦×•×¨</button>
            <button class="btn-outline" style="border:none; color:#888;" onclick="closeModal('modal-create')" id="btnCancelCreate">×‘×™×˜×•×œ</button>
        </div>
    </div>

    <div id="modal-add-player" class="modal-overlay hidden">
        <div class="modal-box">
            <h3 id="addPlayerTitle">×”×•×¡×£ ×©×—×§×Ÿ</h3>
            <input type="text" id="newPlayerName" placeholder="">
            <button class="btn-gold" onclick="addPlayer()" id="btnAddPlayerModal">×”×•×¡×£</button>
            <button class="btn-outline" style="border:none; color:#888;" onclick="closeModal('modal-add-player')" id="btnCancelAddPlayer">×‘×™×˜×•×œ</button>
        </div>
    </div>

    <div id="modal-food" class="modal-overlay hidden">
        <div class="modal-box">
            <h3 id="whoPaidTitle">××™ ×©×™×œ×?</h3>
            <select id="foodPayerSelect"></select>
            
            <div style="margin: 15px 0;">
                <div class="toggle-container">
                    <div class="toggle-btn active" id="btnSplitEqual" onclick="setFoodMode('equal')">×—×œ×•×§×” ×©×•×•×”</div>
                    <div class="toggle-btn" id="btnSplitIndiv" onclick="setFoodMode('indiv')">×œ×¤×™ ×¡×•×¢×“</div>
                </div>
            </div>

            <div id="foodModeEqual">
                <input type="number" id="foodTotalAmount" placeholder="×¡×”×´×› ×œ×ª×©×œ×•×">
                <p style="font-size:0.8rem; color:#888;">×‘×—×¨ ××™ ×”×©×ª×ª×£ ×‘××¨×•×—×”:</p>
                <div id="foodEatersListEqual" style="max-height:150px; overflow-y:auto;"></div>
            </div>

            <div id="foodModeIndiv" class="hidden">
                <p style="font-size:0.8rem; color:#888;">×”×–×Ÿ ×¡×›×•× ×œ×›×œ ××™ ×©×”×–××™×Ÿ:</p>
                <div id="foodEatersListIndiv" style="max-height:200px; overflow-y:auto;"></div>
            </div>

            <button class="btn-gold" onclick="submitFood()">×©××•×¨ ×”×•×¦××”</button>
            <button class="btn-outline" style="border:none; color:#888;" onclick="closeModal('modal-food')">×‘×™×˜×•×œ</button>
        </div>
    </div>

    <div id="modal-share" class="modal-overlay hidden">
        <div class="modal-box" style="text-align:center;">
            <h3 id="scanToJoinTitle">×¡×¨×•×§ ×œ×”×¦×˜×¨×¤×•×ª</h3>
            <img id="qrImage" src="" style="border:5px solid #fff; border-radius:4px; margin:10px 0;">
            <div style="display: flex; gap: 5px; align-items: center; margin: 10px 0;">
                <button class="btn-gold" onclick="copyShareLink()" style="width: 35px; height: 35px; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 1rem; min-width: 35px; flex-shrink: 0;" id="copyLinkBtnTitle" title="">
                    ğŸ“‹
                </button>
                <input type="text" id="shareLink" readonly style="flex: 1; text-align:center; font-size:0.8rem; padding: 6px 8px;">
            </div>
            <button id="btnCloseShare" class="btn-gold" onclick="closeModal('modal-share')">×¡×’×•×¨</button>
        </div>
    </div>

    <script>
        // --- SUPABASE INIT ---
        // Read from environment variables (Vercel) or use defaults
        const SUPABASE_URL = window.SUPABASE_URL || 'https://gfchswspvayyvdlxbggw.supabase.co';
        const SUPABASE_KEY = window.SUPABASE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdmY2hzd3NwdmF5eXZkbHhiZ2d3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MDI1NTUsImV4cCI6MjA3OTM3ODU1NX0.5vIkcgyGEWEW3uI5Y2bJKG7Ex2uhIAsUtC8US6BFVtA';
        
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        // --- STATE ---
        let currentUser = null;
        let currentProfile = null;
        let activeTableId = null;
        let currentFoodMode = 'equal';
        let pendingJoinTableId = null;
        let realtimeChannels = {}; // Store realtime subscriptions
        let isLoading = true; // Loading state for initial auth check
        let currentLanguage = localStorage.getItem('language') || 'he'; // Default to Hebrew
        
        // UUID validation regex (reusable)
        const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

        // --- TRANSLATIONS ---
        const translations = {
            he: {
                // Navigation
                'logout': '×”×ª× ×ª×§',
                'back': '×—×–×•×¨',
                // Auth
                'login': '×”×ª×—×‘×¨×•×ª',
                'signup': '×”×¨×©××”',
                'email': '××™××™×™×œ',
                'password': '×¡×™×¡××”',
                'username': '×©× ××©×ª××©',
                'phone': '×˜×œ×¤×•×Ÿ',
                'loginBtn': '×”×ª×—×‘×¨',
                'signupBtn': '×”×™×¨×©×',
                'loading': '×˜×•×¢×Ÿ...',
                // Lobby
                'activeTables': '×©×•×œ×—× ×•×ª ×¤×¢×™×œ×™×',
                'history': '×”×™×¡×˜×•×¨×™×”',
                'myStats': '×”× ×ª×•× ×™× ×©×œ×™',
                'createTable': '×¤×ª×— ×©×•×œ×—×Ÿ ×—×“×©',
                'deletedTables': '×©×•×œ×—× ×•×ª ×©× ××—×§×•',
                'noActiveTables': '××™×Ÿ ×©×•×œ×—× ×•×ª ×¤×¢×™×œ×™×',
                'noDeletedTables': '××™×Ÿ ×©×•×œ×—× ×•×ª ×©× ××—×§×•',
                'loadingDeleted': '×˜×•×¢×Ÿ ×©×•×œ×—× ×•×ª ×©× ××—×§×•...',
                // Table
                'players': '×©×—×§× ×™×',
                'add': '×”×•×¡×£',
                'gameActivity': '×¤×¢×™×œ×•×ª ×”××©×—×§',
                'showHide': '×”×¦×’/×”×¡×ª×¨',
                'weWereHungry': '×”×™×™× ×• ×¨×¢×‘×™×',
                'shareLink': '×©×ª×£ ×§×™×©×•×¨',
                'settle': '×©×•×œ×',
                'deleteTable': '××—×§ ×©×•×œ×—×Ÿ',
                'hallOfFame': '×”×™×›×œ ×”×ª×”×™×œ×”',
                'shark': '×”×›×¨×™×© (×”×¨×•×•×— ×”×’×“×•×œ ×‘×™×•×ª×¨ ×‘××©×—×§ ×‘×•×“×“)',
                'loser': '×”××¤×¡×™×“ (×”×”×¤×¡×“ ×”×’×“×•×œ ×‘×™×•×ª×¨ ×‘××©×—×§ ×‘×•×“×“)',
                'leagueTable': '×˜×‘×œ×ª ×œ×™×’×” (×©×•×œ×—×Ÿ ×–×” ×‘×œ×‘×“)',
                'player': '×©×—×§×Ÿ',
                'games': '××©×—×§×™×',
                'profitLoss': '×¨×•×•×—/×”×¤×¡×“',
                // Settle
                'settleTitle': '×¡×™×•× ×—×©×‘×•×Ÿ',
                'howMuchCash': '×›××” ×›×¡×£ ×™×© ×œ×›×œ ××—×“ ×‘×™×“?',
                'calculate': '×—×©×‘ ×ª×•×¦××•×ª',
                // Summary
                'gameSummary': '×¡×™×›×•× ××©×—×§',
                'finalResults': '×ª×•×¦××•×ª ×¡×•×¤×™×•×ª',
                'backToLobby': '×—×–×¨×” ×œ×œ×•×‘×™',
                // My Stats
                'myStatsTitle': '×”× ×ª×•× ×™× ×©×œ×™',
                'totalProfitLoss': '×¡×”"×› ×¨×•×•×—/×”×¤×¡×“',
                'gamesPlayed': '××©×—×§×™×',
                'averagePerGame': '×××•×¦×¢ ×œ××©×—×§',
                'biggestWin': '×”×¨×•×•×— ×”×’×“×•×œ ×‘×™×•×ª×¨',
                'biggestLoss': '×”×”×¤×¡×“ ×”×’×“×•×œ ×‘×™×•×ª×¨',
                // History
                'restoreTable': '×©×—×–×¨ ×©×•×œ×—×Ÿ',
                'summary': '×¡×™×›×•×',
                'entry': '×›× ×™×¡×”',
                // Modals
                'tableName': '×©× ×©×•×œ×—×Ÿ',
                'buyIn': '×›× ×™×¡×”',
                'create': '×¦×•×¨',
                'cancel': '×‘×™×˜×•×œ',
                'playerName': '×©× ×©×—×§×Ÿ',
                // Messages
                'tableDeleted': '×”×©×•×œ×—×Ÿ × ××—×§ ×•×¢×‘×¨ ×œ××¨×›×™×•×Ÿ',
                'tableRestored': '×”×©×•×œ×—×Ÿ ×©×•×—×–×¨ ×‘×”×¦×œ×—×”',
                'confirmDelete': '×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ×”×©×•×œ×—×Ÿ? ×”×©×•×œ×—×Ÿ ×™×¢×‘×•×¨ ×œ××¨×›×™×•×Ÿ ×•×™×•×›×œ ×œ×”×™×•×ª ××©×•×—×–×¨.',
                // Emojis (will be added after text in RTL)
                'emojiStats': 'ğŸ“Š',
                'emojiHistory': 'ğŸ“œ',
                'emojiActivity': 'ğŸ“',
                'emojiFood': 'ğŸ”ğŸ•',
                'emojiShare': 'ğŸ”—',
                'emojiSettle': 'ğŸ’°',
                'emojiDelete': 'ğŸ—‘ï¸',
                'emojiHall': 'ğŸ†',
                'emojiShark': 'ğŸ¦ˆ',
                'emojiLoser': 'ğŸ‘',
                'emojiCreate': '+',
                // Additional texts
                'phoneRequired': '××¡×¤×¨ ×˜×œ×¤×•×Ÿ',
                'tableNamePlaceholder': '×©× ×”×©×•×œ×—×Ÿ',
                'pot': '×§×•×¤×”',
                'invested': '×”×©×§×™×¢',
                'loadingLogs': '×˜×•×¢×Ÿ ×œ×•×’×™×...',
                'loadingData': '×˜×•×¢×Ÿ × ×ª×•× ×™×...',
                'updateAndExit': '×¢×“×›×Ÿ × ×ª×•× ×™× ×•×¦× ×œ×œ×•×‘×™',
                'newTable': '×©×•×œ×—×Ÿ ×—×“×©',
                'allTime': '×œ×›×œ ×”×–××Ÿ',
                'noData': '××™×Ÿ × ×ª×•× ×™×',
                'noDataYet': '××™×Ÿ × ×ª×•× ×™× ×¢×“×™×™×Ÿ',
                'scanToJoin': '×¡×¨×•×§ ×œ×”×¦×˜×¨×¤×•×ª',
                'copyLink': '×”×¢×ª×§ ×§×™×©×•×¨',
                'close': '×¡×’×•×¨',
                'error': '×©×’×™××”',
                'errorLoading': '×©×’×™××” ×‘×˜×¢×™× ×”',
                'errorLoadingTables': '×©×’×™××” ×‘×˜×¢×™× ×ª ×©×•×œ×—× ×•×ª',
                'errorLoadingHistory': '×©×’×™××” ×‘×˜×¢×™× ×ª ×”×™×¡×˜×•×¨×™×”',
                'errorLoadingDeleted': '×©×’×™××” ×‘×˜×¢×™× ×ª ×©×•×œ×—× ×•×ª ×©× ××—×§×•',
                'errorLoadingSummary': '×©×’×™××” ×‘×˜×¢×™× ×ª ×”×¡×™×›×•×',
                'errorLoadingStats': '×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™×',
                'errorCreatingTable': '×©×’×™××” ×‘×™×¦×™×¨×ª ×©×•×œ×—×Ÿ',
                'errorAddingPlayer': '×©×’×™××” ×‘×”×•×¡×¤×ª ×©×—×§×Ÿ',
                'errorDeletingTable': '×©×’×™××” ×‘××—×™×§×ª ×©×•×œ×—×Ÿ',
                'errorRestoringTable': '×©×’×™××” ×‘×©×—×–×•×¨ ×©×•×œ×—×Ÿ',
                'errorCalculating': '×©×’×™××” ×‘×—×™×©×•×‘ ×ª×•×¦××•×ª',
                'errorSaving': '×©×’×™××” ×‘×©××™×¨×”',
                'errorCriticalSaving': '×©×’×™××” ×§×¨×™×˜×™×ª ×‘×©××™×¨×”',
                'userNotFound': '××©×ª××© ×œ× × ××¦×',
                'playerAlreadyInTable': '×”×©×—×§×Ÿ ×›×‘×¨ ×‘×©×•×œ×—×Ÿ',
                'playerAdded': '×”×¦×˜×¨×£ ×œ×©×•×œ×—×Ÿ',
                'fillAllFields': '××œ× ××ª ×›×œ ×”×¤×¨×˜×™×',
                'notConnected': '××™× ×š ××—×•×‘×¨. ×× × ×”×ª×—×‘×¨ ××—×“×©.',
                'tableCreatedButNoId': '×©×’×™××”: ×©×•×œ×—×Ÿ × ×•×¦×¨ ××‘×œ ×œ× ×§×™×‘×œ× ×• ID',
                'tableCreatedSuccess': '×©×•×œ×—×Ÿ × ×•×¦×¨ ×‘×”×¦×œ×—×”, ××‘×œ ×”×™×™×ª×” ×‘×¢×™×” ×‘×”×•×¡×¤×ª×š ×›×©×—×§×Ÿ. × × ×œ×”×•×¡×™×£ ××ª ×¢×¦××š ×™×“× ×™×ª.',
                'noDataToSave': '××™×Ÿ × ×ª×•× ×™× ×œ×©××™×¨×”',
                'invalidTable': '×©×’×™××”: ×©×•×œ×—×Ÿ ×œ× ×ª×§×™×Ÿ. × × ×œ×—×–×•×¨ ×œ×œ×•×‘×™ ×•×œ×¤×ª×•×— ×©×•×œ×—×Ÿ ××—×“×©.',
                'dataSavedSuccess': '×”× ×ª×•× ×™× × ×©××¨×• ×‘×”×¦×œ×—×”! ×”×¤×¨×•×¤×™×œ×™× ×¢×•×“×›× ×•.',
                'dataSavedTable': '×”× ×ª×•× ×™× × ×©××¨×• ×‘×©×•×œ×—×Ÿ. (×œ× ×”×™×• ××©×ª××©×™× ×¨×©×•××™× ×ª×§×™× ×™× ×œ×¢×“×›×•×Ÿ ×¤×¨×•×¤×™×œ)',
                'errorSavingHistory': '×©×’×™××” ×‘×©××™×¨×ª ×”×™×¡×˜×•×¨×™×”',
                'dataSavedButStatsNotUpdated': '×”× ×ª×•× ×™× ×‘×©×•×œ×—×Ÿ × ×©××¨×•, ××‘×œ ×”×¡×˜×˜×™×¡×˜×™×§×•×ª ×œ× ×¢×•×“×›× ×•.',
                'noValidPlayers': '×©×’×™××”: ××™×Ÿ ×©×—×§× ×™× ×ª×§×™× ×™× ×œ×©××™×¨×”. ×•×•×“× ×©×›×œ ×”×©×—×§× ×™× ×¨×©×•××™× ×‘××¢×¨×›×ª.',
                'noActiveTableToDelete': '×©×’×™××”: ××™×Ÿ ×©×•×œ×—×Ÿ ×¤×¢×™×œ ×œ××—×™×§×”',
                'invalidTableId': '×©×’×™××”: ××–×”×” ×©×•×œ×—×Ÿ ×œ× ×ª×§×™×Ÿ',
                'tableNotFound': '×©×•×œ×—×Ÿ ×œ× × ××¦×',
                'cannotLoadTable': '×œ× × ×™×ª×Ÿ ×œ×˜×¢×•×Ÿ ××ª ×”×©×•×œ×—×Ÿ',
                'allBalanced': '×›×•×œ× ×××•×–× ×™×!',
                'transfersToMake': '×”×¢×‘×¨×•×ª ×œ×‘×™×¦×•×¢:',
                'transfers': '××¢×‘×™×¨',
                'to': '×œ',
                'payWithBit': '×©×œ× ×¢× Bit',
                'whoPaid': '××™ ×©×™×œ×?',
                'noPlayers': '××™×Ÿ ×©×—×§× ×™×',
                'missingDetails': '×—×¡×¨×™× ×¤×¨×˜×™×',
                'noAmountsEntered': '×œ× ×”×•×–× ×• ×¡×›×•××™×',
                'buyInPrice': '××—×™×¨ ×›× ×™×¡×” (â‚ª)',
                'allTimeText': '×œ×›×œ ×”×–××Ÿ'
            },
            en: {
                // Navigation
                'logout': 'Logout',
                'back': 'Back',
                // Auth
                'login': 'Login',
                'signup': 'Sign Up',
                'email': 'Email',
                'password': 'Password',
                'username': 'Username',
                'phone': 'Phone',
                'loginBtn': 'Login',
                'signupBtn': 'Sign Up',
                'loading': 'Loading...',
                // Lobby
                'activeTables': 'Active Tables',
                'history': 'History',
                'myStats': 'My Stats',
                'createTable': 'Create New Table',
                'deletedTables': 'Deleted Tables',
                'noActiveTables': 'No active tables',
                'noDeletedTables': 'No deleted tables',
                'loadingDeleted': 'Loading deleted tables...',
                // Table
                'players': 'Players',
                'add': 'Add',
                'gameActivity': 'Game Activity',
                'showHide': 'Show/Hide',
                'weWereHungry': 'We Were Hungry',
                'shareLink': 'Share Link',
                'settle': 'Settle',
                'deleteTable': 'Delete Table',
                'hallOfFame': 'Hall of Fame',
                'shark': 'The Shark (Biggest single-game win)',
                'loser': 'The Loser (Biggest single-game loss)',
                'leagueTable': 'League Table (This table only)',
                'player': 'Player',
                'games': 'Games',
                'profitLoss': 'Profit/Loss',
                // Settle
                'settleTitle': 'Settle Game',
                'howMuchCash': 'How much cash does each player have?',
                'calculate': 'Calculate Results',
                // Summary
                'gameSummary': 'Game Summary',
                'finalResults': 'Final Results',
                'backToLobby': 'Back to Lobby',
                // My Stats
                'myStatsTitle': 'My Stats',
                'totalProfitLoss': 'Total Profit/Loss',
                'gamesPlayed': 'Games Played',
                'averagePerGame': 'Average Per Game',
                'biggestWin': 'Biggest Win',
                'biggestLoss': 'Biggest Loss',
                // History
                'restoreTable': 'Restore Table',
                'summary': 'Summary',
                'entry': 'Entry',
                // Modals
                'tableName': 'Table Name',
                'buyIn': 'Buy In',
                'create': 'Create',
                'cancel': 'Cancel',
                'playerName': 'Player Name',
                // Messages
                'tableDeleted': 'Table deleted and moved to archive',
                'tableRestored': 'Table restored successfully',
                'confirmDelete': 'Are you sure you want to delete this table? The table will be moved to archive and can be restored.',
                // Emojis
                'emojiStats': 'ğŸ“Š',
                'emojiHistory': 'ğŸ“œ',
                'emojiActivity': 'ğŸ“',
                'emojiFood': 'ğŸ”ğŸ•',
                'emojiShare': 'ğŸ”—',
                'emojiSettle': 'ğŸ’°',
                'emojiDelete': 'ğŸ—‘ï¸',
                'emojiHall': 'ğŸ†',
                'emojiShark': 'ğŸ¦ˆ',
                'emojiLoser': 'ğŸ‘',
                'emojiCreate': '+',
                // Additional texts
                'phoneRequired': 'Phone Number',
                'tableNamePlaceholder': 'Table Name',
                'pot': 'Pot',
                'invested': 'Invested',
                'loadingLogs': 'Loading logs...',
                'loadingData': 'Loading data...',
                'updateAndExit': 'Update Data and Exit to Lobby',
                'newTable': 'New Table',
                'allTime': 'All Time',
                'noData': 'No Data',
                'noDataYet': 'No data yet',
                'scanToJoin': 'Scan to Join',
                'copyLink': 'Copy Link',
                'close': 'Close',
                'error': 'Error',
                'errorLoading': 'Error loading',
                'errorLoadingTables': 'Error loading tables',
                'errorLoadingHistory': 'Error loading history',
                'errorLoadingDeleted': 'Error loading deleted tables',
                'errorLoadingSummary': 'Error loading summary',
                'errorLoadingStats': 'Error loading data',
                'errorCreatingTable': 'Error creating table',
                'errorAddingPlayer': 'Error adding player',
                'errorDeletingTable': 'Error deleting table',
                'errorRestoringTable': 'Error restoring table',
                'errorCalculating': 'Error calculating results',
                'errorSaving': 'Error saving',
                'errorCriticalSaving': 'Critical error saving',
                'userNotFound': 'User not found',
                'playerAlreadyInTable': 'Player already in table',
                'playerAdded': 'joined the table',
                'fillAllFields': 'Fill all fields',
                'notConnected': 'You are not connected. Please log in again.',
                'tableCreatedButNoId': 'Error: Table created but did not receive ID',
                'tableCreatedSuccess': 'Table created successfully, but there was a problem adding you as a player. Please add yourself manually.',
                'noDataToSave': 'No data to save',
                'invalidTable': 'Error: Invalid table. Please return to lobby and open table again.',
                'dataSavedSuccess': 'Data saved successfully! Profiles updated.',
                'dataSavedTable': 'Data saved in table. (No valid registered users for profile update)',
                'errorSavingHistory': 'Error saving history',
                'dataSavedButStatsNotUpdated': 'Data saved in table, but statistics were not updated.',
                'noValidPlayers': 'Error: No valid players to save. Make sure all players are registered in the system.',
                'noActiveTableToDelete': 'Error: No active table to delete',
                'invalidTableId': 'Error: Invalid table ID',
                'tableNotFound': 'Table not found',
                'cannotLoadTable': 'Cannot load table',
                'allBalanced': 'Everyone is balanced!',
                'transfersToMake': 'Transfers to make:',
                'transfers': 'transfers',
                'to': 'to',
                'payWithBit': 'Pay with Bit',
                'whoPaid': 'Who paid?',
                'noPlayers': 'No players',
                'missingDetails': 'Missing details',
                'noAmountsEntered': 'No amounts entered',
                'buyInPrice': 'Buy In (â‚ª)',
                'allTimeText': 'All Time'
            }
        };

        function t(key) {
            return translations[currentLanguage][key] || key;
        }

        function changeLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('language', lang);
            document.documentElement.lang = lang;
            document.documentElement.dir = lang === 'he' ? 'rtl' : 'ltr';

            // Update language selectors
            const selector = document.getElementById('languageSelector');
            if (selector) {
                selector.value = lang;
            }
            const authSelector = document.getElementById('authLanguageSelector');
            if (authSelector) {
                authSelector.value = lang;
            }

            // Update all UI elements including placeholders
            updateUI();
            
            // Re-render current view
            if (currentUser) {
                if (activeTableId) {
                    renderTable();
                    renderHallOfFame();
                } else {
                    renderLobby();
                }
            }
        }

        function updateUI() {
            // Update all text elements that are always visible
            if (document.getElementById('btnLogout')) {
                document.getElementById('btnLogout').textContent = t('logout');
            }
            if (document.getElementById('deletedTablesTitle')) {
                document.getElementById('deletedTablesTitle').textContent = t('deletedTables');
            }
            // Update tabs
            const activeTab = document.getElementById('tab-active-games');
            const historyTab = document.getElementById('tab-history');
            if (activeTab) activeTab.textContent = t('activeTables');
            if (historyTab) historyTab.textContent = t('history');
            
            // Update loading texts
            if (document.getElementById('loadingText')) {
                document.getElementById('loadingText').textContent = t('loading');
            }
            if (document.getElementById('loadingTablesText')) {
                document.getElementById('loadingTablesText').textContent = t('loading');
            }
            if (document.getElementById('loadingStatsText')) {
                document.getElementById('loadingStatsText').textContent = t('loadingData');
            }
            if (document.getElementById('loadingLogsText')) {
                document.getElementById('loadingLogsText').textContent = t('loadingLogs');
            }
            
            // Update auth tabs
            if (document.getElementById('tabLoginText')) {
                document.getElementById('tabLoginText').textContent = t('login');
            }
            if (document.getElementById('tabSignupText')) {
                document.getElementById('tabSignupText').textContent = t('signup');
            }
            if (document.getElementById('loginTitle')) {
                document.getElementById('loginTitle').textContent = t('login');
            }
            if (document.getElementById('signupTitle')) {
                document.getElementById('signupTitle').textContent = t('signup');
            }
            if (document.getElementById('btnLogin')) {
                document.getElementById('btnLogin').textContent = t('loginBtn');
            }
            if (document.getElementById('btnSignup')) {
                document.getElementById('btnSignup').textContent = t('signupBtn');
            }
            
            // Update placeholders
            if (document.getElementById('loginEmail')) {
                document.getElementById('loginEmail').placeholder = t('email');
            }
            if (document.getElementById('loginPassword')) {
                document.getElementById('loginPassword').placeholder = t('password');
            }
            if (document.getElementById('signupUsername')) {
                document.getElementById('signupUsername').placeholder = t('username');
            }
            if (document.getElementById('signupEmail')) {
                document.getElementById('signupEmail').placeholder = t('email');
            }
            if (document.getElementById('signupPhone')) {
                document.getElementById('signupPhone').placeholder = t('phoneRequired');
            }
            if (document.getElementById('signupPassword')) {
                document.getElementById('signupPassword').placeholder = t('password');
            }
            
            // Update lobby
            if (document.getElementById('activeTablesTitle')) {
                document.getElementById('activeTablesTitle').textContent = t('activeTables');
            }
            if (document.getElementById('myStatsBtnText')) {
                document.getElementById('myStatsBtnText').textContent = t('myStats');
            }
            if (document.getElementById('btnCreateTable')) {
                const btn = document.getElementById('btnCreateTable');
                btn.innerHTML = t('createTable') + ' <span style="margin-right: 5px;">+</span>';
            }
            
            // Update my stats
            if (document.getElementById('myStatsPageTitle')) {
                document.getElementById('myStatsPageTitle').textContent = t('myStatsTitle');
            }
            
            // Update summary
            if (document.getElementById('summaryTitle')) {
                document.getElementById('summaryTitle').textContent = t('gameSummary');
            }
            if (document.getElementById('finalResultsTitle')) {
                document.getElementById('finalResultsTitle').textContent = t('finalResults');
            }
            if (document.getElementById('btnBackToLobby')) {
                document.getElementById('btnBackToLobby').textContent = t('backToLobby');
            }
            
            // Update table view
            if (document.getElementById('entryLabel')) {
                document.getElementById('entryLabel').textContent = t('entry');
            }
            if (document.getElementById('potLabel')) {
                document.getElementById('potLabel').textContent = t('pot');
            }
            if (document.getElementById('playersLabel')) {
                document.getElementById('playersLabel').textContent = t('players');
            }
            if (document.getElementById('addPlayerText')) {
                document.getElementById('addPlayerText').textContent = t('add');
            }
            if (document.getElementById('gameActivityLabel')) {
                document.getElementById('gameActivityLabel').innerHTML = t('gameActivity') + ' <span style="margin-right: 5px;">ğŸ“</span>';
            }
            if (document.getElementById('btnToggleLogs')) {
                document.getElementById('btnToggleLogs').textContent = t('showHide');
            }
            if (document.getElementById('btnWeWereHungry')) {
                document.getElementById('btnWeWereHungry').innerHTML = t('weWereHungry') + ' <span style="margin-right: 5px;">ğŸ”ğŸ•</span>';
            }
            if (document.getElementById('btnShareLink')) {
                document.getElementById('btnShareLink').innerHTML = t('shareLink') + ' <span style="margin-right: 5px;">ğŸ”—</span>';
            }
            if (document.getElementById('btnSettle')) {
                document.getElementById('btnSettle').innerHTML = t('settle') + ' <span style="margin-right: 5px;">ğŸ’°</span>';
            }
            if (document.getElementById('deleteTableText')) {
                document.getElementById('deleteTableText').textContent = t('deleteTable');
            }
            if (document.getElementById('hallOfFameBtnText')) {
                document.getElementById('hallOfFameBtnText').textContent = t('hallOfFame');
            }
            if (document.getElementById('hallOfFameTitle')) {
                document.getElementById('hallOfFameTitle').textContent = t('hallOfFame');
            }
            if (document.getElementById('sharkTitle')) {
                document.getElementById('sharkTitle').textContent = t('shark');
            }
            if (document.getElementById('loserTitle')) {
                document.getElementById('loserTitle').textContent = t('loser');
            }
            if (document.getElementById('leagueTableTitle')) {
                document.getElementById('leagueTableTitle').textContent = t('leagueTable');
            }
            if (document.getElementById('thPlayer')) {
                document.getElementById('thPlayer').textContent = t('player');
            }
            if (document.getElementById('thGames')) {
                document.getElementById('thGames').textContent = t('games');
            }
            if (document.getElementById('thProfitLoss')) {
                document.getElementById('thProfitLoss').textContent = t('profitLoss');
            }
            
            // Update settle view
            if (document.getElementById('settlePageTitle')) {
                document.getElementById('settlePageTitle').textContent = t('settleTitle');
            }
            if (document.getElementById('howMuchCashTitle')) {
                document.getElementById('howMuchCashTitle').textContent = t('howMuchCash');
            }
            if (document.getElementById('btnCalculate')) {
                document.getElementById('btnCalculate').textContent = t('calculate');
            }
            if (document.getElementById('updateAndExitText')) {
                document.getElementById('updateAndExitText').textContent = t('updateAndExit');
            }
            
            // Update modals
            if (document.getElementById('newTableTitle')) {
                document.getElementById('newTableTitle').textContent = t('newTable');
            }
            if (document.getElementById('newTableName')) {
                document.getElementById('newTableName').placeholder = t('tableNamePlaceholder');
            }
            if (document.getElementById('newTableBuyIn')) {
                document.getElementById('newTableBuyIn').placeholder = currentLanguage === 'he' ? '××—×™×¨ ×›× ×™×¡×” (â‚ª)' : 'Buy In (â‚ª)';
            }
            if (document.getElementById('btnCreate')) {
                document.getElementById('btnCreate').textContent = t('create');
            }
            if (document.getElementById('btnCancelCreate')) {
                document.getElementById('btnCancelCreate').textContent = t('cancel');
            }
            if (document.getElementById('addPlayerTitle')) {
                document.getElementById('addPlayerTitle').textContent = t('add') + ' ' + t('player');
            }
            if (document.getElementById('newPlayerName')) {
                document.getElementById('newPlayerName').placeholder = t('playerName');
            }
            if (document.getElementById('btnAddPlayerModal')) {
                document.getElementById('btnAddPlayerModal').textContent = t('add');
            }
            if (document.getElementById('btnCancelAddPlayer')) {
                document.getElementById('btnCancelAddPlayer').textContent = t('cancel');
            }
            
            // Back button arrow direction is handled by CSS transform based on dir attribute
            
            // Update share modal
            if (document.getElementById('scanToJoinTitle')) {
                document.getElementById('scanToJoinTitle').textContent = t('scanToJoin');
            }
            if (document.getElementById('copyLinkBtnTitle')) {
                document.getElementById('copyLinkBtnTitle').title = t('copyLink');
            }
            if (document.getElementById('btnCloseShare')) {
                document.getElementById('btnCloseShare').textContent = t('close');
            }
        }

        // Initialize language on page load
        function initLanguage() {
            const savedLang = localStorage.getItem('language') || 'he';
            currentLanguage = savedLang;
            document.documentElement.lang = savedLang;
            document.documentElement.dir = savedLang === 'he' ? 'rtl' : 'ltr';
            const selector = document.getElementById('languageSelector');
            if (selector) {
                selector.value = savedLang;
            }
            const authSelector = document.getElementById('authLanguageSelector');
            if (authSelector) {
                authSelector.value = savedLang;
            }
            // Update UI with correct language (including placeholders)
            updateUI();
            
            // Back button arrow direction is handled by CSS transform based on dir attribute
        }

        // --- TOAST NOTIFICATION ---
        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        // --- AUTHENTICATION ---
        async function checkAuth() {
            // Show loading screen immediately
            isLoading = true;
            showLoading();
            
            console.log('ğŸ”„ Starting auth check...');
            console.log('ğŸ“ Current URL:', window.location.href);
            
            // Check for email confirmation token in URL
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            const type = urlParams.get('type');
            const tokenHash = urlParams.get('token_hash');
            
            // Check if there's a tableId in URL (before checking session)
            const tableIdFromURL = getTableIdFromURL();
            if (tableIdFromURL) {
                console.log('ğŸ” Found tableId in URL before session check:', tableIdFromURL);
            }
            
            if ((token || tokenHash) && (type === 'signup' || type === 'email')) {
                // User clicked email confirmation link
                try {
                    const verifyToken = tokenHash || token;
                    const { data, error } = await supabase.auth.verifyOtp({
                        token_hash: verifyToken,
                        type: type === 'signup' ? 'signup' : 'email'
                    });
                    
                    if (error) {
                        console.error('Email verification error:', error);
                        const errorDiv = document.getElementById('loginError') || document.getElementById('signupError');
                        if (errorDiv) {
                            errorDiv.textContent = '×©×’×™××” ×‘××™××•×ª ××™××™×™×œ. × ×¡×” ×œ×”×ª×—×‘×¨ ×™×“× ×™×ª.';
                            errorDiv.style.color = 'var(--red)';
                            errorDiv.classList.remove('hidden');
                        }
                    } else {
                        console.log('Email verified successfully');
                        showToast('××™××™×™×œ ××•××ª ×‘×”×¦×œ×—×”!');
                    }
                    
                    // Clean URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                } catch (err) {
                    console.error('Error verifying email:', err);
                }
            }
            
            // CRITICAL: Wait for session before making any navigation decisions
            // In a new window/tab, session might need a moment to load from localStorage
            console.log('â³ Waiting for session...');
            
            let session = null;
            let sessionError = null;
            let attempts = 0;
            const maxAttempts = 3;
            
            // Try to get session with retries (for new windows/tabs)
            while (attempts < maxAttempts && !session) {
                const result = await supabase.auth.getSession();
                session = result.data?.session;
                sessionError = result.error;
                
                if (session) {
                    console.log(`âœ… Session found on attempt ${attempts + 1}`);
                    break;
                }
                
                attempts++;
                if (attempts < maxAttempts) {
                    console.log(`â³ Session not found, retrying... (${attempts}/${maxAttempts})`);
                    // Wait a bit before retrying (for new windows/tabs)
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            if (sessionError && !session) {
                console.error('Session error:', sessionError);
                isLoading = false;
                showAuth();
                return;
            }
            
            if (session) {
                console.log('âœ… Session found, user:', session.user.id);
                currentUser = session.user;
                await loadProfile();
                
                // NOW check if there's a tableId in URL
                const tableIdFromURL = getTableIdFromURL();
                console.log('ğŸ” Checking URL for tableId:', tableIdFromURL);
                
                if (tableIdFromURL) {
                    // Try to load the table
                    console.log('ğŸš€ Attempting to load table from URL:', tableIdFromURL);
                    
                    try {
                        // Check if table exists and user has access
                        const { data: table, error: tableError } = await supabase
                            .from('tables')
                            .select('*')
                            .eq('id', tableIdFromURL)
                            .single();
                        
                        if (tableError || !table) {
                            console.error('âŒ Table not found:', tableError);
                            // Table doesn't exist - clear URL and show lobby
                            if (tableError && tableError.code === 'PGRST116') {
                                clearTableFromURL();
                            }
                            isLoading = false;
                            handleJoinFlow();
                            showLobby();
                            return;
                        }
                        
                        console.log('âœ… Table found:', table.name);
                        
                        // Check if user is owner or player
                        const { data: player, error: playerError } = await supabase
                            .from('table_players')
                            .select('*')
                            .eq('table_id', tableIdFromURL)
                            .eq('user_id', currentUser.id)
                            .single();
                        
                        const isOwner = table.owner_id === currentUser.id;
                        const isPlayer = !playerError && player !== null;
                        
                        console.log('Access check:', { isOwner, isPlayer, playerError: playerError?.code });
                        
                        if (isOwner || isPlayer) {
                            // User has access - open the table directly (skip lobby)
                            console.log('âœ… User has access - opening table directly');
                            isLoading = false;
                            await openTable(tableIdFromURL);
                            return; // Exit - don't show lobby
                        } else {
                            // User doesn't have access
                            console.log('âš ï¸ User does not have access to this table');
                            // Check if it's a join link
                            const joinTableParam = urlParams.get('joinTable');
                            if (joinTableParam === tableIdFromURL) {
                                handleJoinFlow();
                            }
                            isLoading = false;
                            showLobby();
                            return;
                        }
                    } catch (error) {
                        console.error('âŒ Error loading table:', error);
                        // On error, clear URL and show lobby
                        clearTableFromURL();
                        isLoading = false;
                        handleJoinFlow();
                        showLobby();
                        return;
                    }
                } else {
                    // No tableId in URL - normal flow
                    console.log('ğŸ“‹ No tableId in URL - showing lobby');
                    isLoading = false;
                    handleJoinFlow();
                    showLobby();
                }
            } else {
                // Not logged in
                console.log('âŒ No session - showing auth');
                // Check if there's a tableId in URL to remember it
                const tableIdFromURL = getTableIdFromURL();
                if (tableIdFromURL) {
                    pendingJoinTableId = tableIdFromURL;
                    console.log('ğŸ’¾ Stored tableId for after login:', tableIdFromURL);
                }
                isLoading = false;
                showAuth();
            }
        }

        async function loadProfile() {
            if (!currentUser) return;
            const { data, error } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', currentUser.id)
                .single();
            
            if (error && error.code !== 'PGRST116') {
                console.error('Error loading profile:', error);
            } else if (data) {
                currentProfile = data;
                document.getElementById('userName').textContent = data.username || '××©×ª××©';
                document.getElementById('userMenu').style.display = 'flex';
            }
        }

        async function handleSignup() {
            const email = document.getElementById('signupEmail').value;
            const password = document.getElementById('signupPassword').value;
            const username = document.getElementById('signupUsername').value.trim();
            const phone = document.getElementById('signupPhone').value;
            const errorDiv = document.getElementById('signupError');

            // Clear previous errors
            errorDiv.classList.add('hidden');
            errorDiv.textContent = '';

            if (!email || !password || !username || !phone) {
                errorDiv.textContent = '××œ× ××ª ×›×œ ×”×©×“×•×ª (×›×•×œ×œ ××¡×¤×¨ ×˜×œ×¤×•×Ÿ)';
                errorDiv.classList.remove('hidden');
                return;
            }

            // Validate phone number (10 digits)
            if (!/^[0-9]{10}$/.test(phone)) {
                errorDiv.textContent = '××¡×¤×¨ ×˜×œ×¤×•×Ÿ ×—×™×™×‘ ×œ×”×™×•×ª 10 ×¡×¤×¨×•×ª';
                errorDiv.classList.remove('hidden');
                return;
            }

            // Validate username (not empty after trim)
            if (username.length === 0) {
                errorDiv.textContent = '×©× ××©×ª××© ×œ× ×™×›×•×œ ×œ×”×™×•×ª ×¨×™×§';
                errorDiv.classList.remove('hidden');
                return;
            }

            try {
                // Sign up user
                const { data: authData, error: authError } = await supabase.auth.signUp({
                    email,
                    password
                });

                if (authError) {
                    console.error('Auth error:', authError);
                    
                    // Handle specific signup errors
                    if (authError.message.includes('already registered') || 
                        authError.message.includes('already exists') ||
                        authError.code === 'user_already_registered') {
                        errorDiv.textContent = '×”××™××™×™×œ ×”×–×” ×›×‘×¨ ×¨×©×•× ×‘××¢×¨×›×ª. × ×¡×” ×œ×”×ª×—×‘×¨ ×‘××§×•×.';
                        errorDiv.style.color = 'var(--red)';
                        errorDiv.classList.remove('hidden');
                        setTimeout(() => {
                            switchAuthTab('login');
                            document.getElementById('loginEmail').value = email;
                        }, 2000);
                        return;
                    }
                    
                    if (authError.message.includes('password')) {
                        errorDiv.textContent = '×”×¡×™×¡××” ×—×œ×©×” ××“×™. ×× × ×”×©×ª××© ×‘×¡×™×¡××” ×—×–×§×” ×™×•×ª×¨ (×œ×¤×—×•×ª 6 ×ª×•×•×™×).';
                        errorDiv.style.color = 'var(--red)';
                        errorDiv.classList.remove('hidden');
                        return;
                    }
                    
                    errorDiv.textContent = '×©×’×™××” ×‘×”×¨×©××”: ' + (authError.message || '× ×¡×” ×©×•×‘ ×××•×—×¨ ×™×•×ª×¨');
                    errorDiv.style.color = 'var(--red)';
                    errorDiv.classList.remove('hidden');
                    return;
                }

                if (!authData.user) {
                    throw new Error('×œ× × ×™×ª×Ÿ ×œ×™×¦×•×¨ ××©×ª××©. × ×¡×” ×©×•×‘.');
                }

                console.log('User created:', authData.user.id);

                // CRITICAL: Try to sign in FIRST to get a session
                // Without a session, auth.uid() will be null and RLS will block the insert
                let session = null;
                
                // Check if we already have a session from signup
                const { data: { session: existingSession } } = await supabase.auth.getSession();
                if (existingSession) {
                    session = existingSession;
                    console.log('Session exists from signup');
                } else {
                    // Try to sign in to get a session
                    console.log('No session, attempting sign in...');
                    const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
                        email,
                        password
                    });
                    
                    if (signInError) {
                        console.error('Sign in error:', signInError);
                        // If email confirmation is required, we can't sign in yet
                        if (signInError.message.includes('Email not confirmed') || signInError.message.includes('email')) {
                            errorDiv.textContent = '×”×¨×©××” ×”×¦×œ×™×—×”! ×× × ×‘×“×•×§ ××ª ×”××™××™×™×œ ×©×œ×š ×œ××™××•×ª ×•××– ×”×ª×—×‘×¨.';
                            errorDiv.style.color = 'var(--green)';
                            errorDiv.classList.remove('hidden');
                            setTimeout(() => {
                                switchAuthTab('login');
                                document.getElementById('loginEmail').value = email;
                            }, 2000);
                            return;
                        }
                        throw new Error('×œ× × ×™×ª×Ÿ ×œ×”×ª×—×‘×¨ ××—×¨×™ ×”×¨×©××”. × ×¡×” ×œ×”×ª×—×‘×¨ ×™×“× ×™×ª.');
                    }
                    
                    session = signInData.session;
                    console.log('Signed in successfully, session:', session ? 'exists' : 'none');
                }

                // Now we have a session, create/update profile
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Check if profile already exists (from trigger)
                const { data: existingProfile } = await supabase
                    .from('profiles')
                    .select('*')
                    .eq('id', authData.user.id)
                    .single();

                if (existingProfile) {
                    // Profile exists, update it with username and phone
                    console.log('Profile exists, updating...');
                    const { error: updateError } = await supabase
                        .from('profiles')
                        .update({
                            username: username,
                            email: email,
                            phone_number: phone
                        })
                        .eq('id', authData.user.id);

                    if (updateError) {
                        console.error('Profile update error:', updateError);
                        throw new Error('×©×’×™××” ×‘×¢×“×›×•×Ÿ ×¤×¨×•×¤×™×œ: ' + updateError.message);
                    }
                    console.log('Profile updated successfully');
                } else {
                    // Profile doesn't exist, create it (now we have a session!)
                    console.log('Creating profile for user:', authData.user.id);
                    
                    // Verify we have a session
                    const { data: { session: verifySession } } = await supabase.auth.getSession();
                    if (!verifySession) {
                        throw new Error('××™×Ÿ session ×¤×¢×™×œ. × ×¡×” ×œ×”×ª×—×‘×¨ ×™×“× ×™×ª.');
                    }
                    
                    const { data: profileData, error: profileError } = await supabase
                        .from('profiles')
                        .insert([{
                            id: authData.user.id,
                            username: username,
                            email: email,
                            phone_number: phone
                        }])
                        .select()
                        .single();

                    if (profileError) {
                        console.error('Profile error details:', {
                            code: profileError.code,
                            message: profileError.message,
                            details: profileError.details,
                            hint: profileError.hint,
                            userId: authData.user.id,
                            hasSession: !!verifySession
                        });
                        
                        if (profileError.code === '23505') {
                            throw new Error('×©× ×”××©×ª××© ×›×‘×¨ ×ª×¤×•×¡. ×‘×—×¨ ×©× ××—×¨.');
                        } else if (profileError.code === '42501' || profileError.message.includes('row-level security') || profileError.message.includes('RLS') || profileError.message.includes('policy')) {
                            throw new Error('×‘×¢×™×™×ª ×”×¨×©××•×ª RLS. ×©×’×™××”: ' + profileError.message + '. ×•×“× ×©×™×© ×œ×š session ×¤×¢×™×œ.');
                        } else {
                            throw new Error('×©×’×™××” ×‘×™×¦×™×¨×ª ×¤×¨×•×¤×™×œ: ' + profileError.message + ' (×§×•×“: ' + (profileError.code || 'unknown') + ')');
                        }
                    }
                    
                    console.log('Profile created successfully:', profileData);
                }

                // Now set current user from the session we have
                const { data: { session: finalSession } } = await supabase.auth.getSession();
                
                if (finalSession) {
                    currentUser = finalSession.user;
                    await loadProfile();
                    
                    // Check if there's a tableId in URL
                    const tableIdFromURL = getTableIdFromURL();
                    if (tableIdFromURL) {
                        // Try to open the table
                        try {
                            await openTable(tableIdFromURL);
                        } catch (error) {
                            console.error('Error opening table from URL after signup:', error);
                            // If there's a pending join, handle it now
                            if (pendingJoinTableId) {
                                await joinTable(pendingJoinTableId);
                                pendingJoinTableId = null;
                            } else {
                                showLobby();
                            }
                        }
                    } else if (pendingJoinTableId) {
                        // If there's a pending join, handle it now
                        await joinTable(pendingJoinTableId);
                        pendingJoinTableId = null;
                    } else {
                        showLobby();
                    }
                } else {
                    // This shouldn't happen, but just in case
                    throw new Error('×œ× × ×™×ª×Ÿ ×œ×§×‘×œ session. × ×¡×” ×œ×”×ª×—×‘×¨ ×™×“× ×™×ª.');
                }
            } catch (error) {
                console.error('Signup error:', error);
                errorDiv.textContent = error.message || '×©×’×™××” ×‘×”×¨×©××”. × ×¡×” ×©×•×‘.';
                errorDiv.style.color = 'var(--red)';
                errorDiv.classList.remove('hidden');
            }
        }

        async function handleLogin() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            const errorDiv = document.getElementById('loginError');

            if (!email || !password) {
                errorDiv.textContent = '××œ× ××ª ×›×œ ×”×©×“×•×ª';
                errorDiv.classList.remove('hidden');
                return;
            }

            try {
                // Clear error div
                errorDiv.classList.add('hidden');
                errorDiv.textContent = '';

                const { data, error } = await supabase.auth.signInWithPassword({
                    email,
                    password
                });

                if (error) {
                    console.error('Login error:', error);
                    
                    // Handle specific error cases with better messages
                    if (error.message.includes('Email not confirmed') || error.message.includes('email')) {
                        errorDiv.textContent = '×”××™××™×™×œ ×œ× ××•××ª. ×× × ×‘×“×•×§ ××ª ×ª×™×‘×ª ×”×“×•××¨ ×©×œ×š ×•×œ×—×¥ ×¢×œ ×”×§×™×©×•×¨ ×œ××™××•×ª. ×× ×œ× ×§×™×‘×œ×ª ××™××™×™×œ, × ×¡×” ×œ×‘×§×© ××™××™×™×œ ××™××•×ª ××—×“×©.';
                        errorDiv.style.color = 'var(--red)';
                        errorDiv.classList.remove('hidden');
                        return;
                    }
                    
                    if (error.message.includes('Invalid login credentials') || 
                        error.message.includes('credentials') ||
                        error.message.includes('Invalid') ||
                        error.code === 'invalid_credentials') {
                        errorDiv.textContent = '×¡×™×¡××” ××• ××™××™×™×œ ×œ× × ×›×•× ×™×. ×× × ×‘×“×•×§ ××ª ×”×¤×¨×˜×™× ×•× ×¡×” ×©×•×‘.';
                        errorDiv.style.color = 'var(--red)';
                        errorDiv.classList.remove('hidden');
                        return;
                    }
                    
                    // Generic error message
                    errorDiv.textContent = '×©×’×™××” ×‘×”×ª×—×‘×¨×•×ª: ' + (error.message || '× ×¡×” ×©×•×‘ ×××•×—×¨ ×™×•×ª×¨');
                    errorDiv.style.color = 'var(--red)';
                    errorDiv.classList.remove('hidden');
                    return;
                }

                // Verify session is properly set (important for cross-device login)
                const { data: { session: verifySession } } = await supabase.auth.getSession();
                if (!verifySession) {
                    console.warn('Session not found after login, retrying...');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const { data: { session: retrySession } } = await supabase.auth.getSession();
                    if (!retrySession) {
                        errorDiv.textContent = '×©×’×™××” ×‘×©××™×¨×ª ×”×”×ª×—×‘×¨×•×ª. × ×¡×” ×©×•×‘.';
                        errorDiv.style.color = 'var(--red)';
                        errorDiv.classList.remove('hidden');
                        return;
                    }
                }

                currentUser = data.user;
                await loadProfile();
                
                // Clear error on success
                errorDiv.classList.add('hidden');
                errorDiv.textContent = '';
                
                // Check if there's a tableId in URL
                const tableIdFromURL = getTableIdFromURL();
                if (tableIdFromURL) {
                    // Try to open the table
                    try {
                        await openTable(tableIdFromURL);
                    } catch (error) {
                        console.error('Error opening table from URL after login:', error);
                        // If there's a pending join, handle it now
                        if (pendingJoinTableId) {
                            await joinTable(pendingJoinTableId);
                            pendingJoinTableId = null;
                        } else {
                            showLobby();
                        }
                    }
                } else if (pendingJoinTableId) {
                    // If there's a pending join, handle it now
                    await joinTable(pendingJoinTableId);
                    pendingJoinTableId = null;
                } else {
                    showLobby();
                }
            } catch (error) {
                errorDiv.textContent = error.message || '×©×’×™××” ×‘×”×ª×—×‘×¨×•×ª';
                errorDiv.style.color = 'var(--red)';
                errorDiv.classList.remove('hidden');
            }
        }

        async function handleLogout() {
            // Unsubscribe from all realtime channels
            Object.values(realtimeChannels).forEach(channel => {
                channel.unsubscribe();
            });
            realtimeChannels = {};
            
            await supabase.auth.signOut();
            currentUser = null;
            currentProfile = null;
            showAuth();
        }

        function switchAuthTab(tab) {
            document.getElementById('tab-login').classList.toggle('active', tab === 'login');
            document.getElementById('tab-signup').classList.toggle('active', tab === 'signup');
            document.getElementById('auth-form-login').classList.toggle('hidden', tab !== 'login');
            document.getElementById('auth-form-signup').classList.toggle('hidden', tab !== 'signup');
            document.getElementById('loginError').classList.add('hidden');
            document.getElementById('signupError').classList.add('hidden');
        }

        // Language menu functions
        function toggleAuthLanguageMenu() {
            const menu = document.getElementById('authLanguageMenu');
            if (menu) {
                menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            }
        }

        function selectAuthLanguage(lang) {
            changeLanguage(lang);
            const menu = document.getElementById('authLanguageMenu');
            if (menu) {
                menu.style.display = 'none';
            }
        }

        // Close menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('authLanguageMenu');
            const button = event.target.closest('#languageToggleBtn');
            const menuItem = event.target.closest('#authLanguageMenu');
            if (menu && menu.style.display === 'block' && !button && !menuItem) {
                menu.style.display = 'none';
            }
        });

        // --- JOIN FLOW ---
        function handleJoinFlow() {
            const urlParams = new URLSearchParams(window.location.search);
            const joinTableId = urlParams.get('joinTable');
            
            if (joinTableId) {
                if (currentUser) {
                    // User is logged in, join immediately
                    joinTable(joinTableId);
                } else {
                    // User not logged in, store for after auth
                    pendingJoinTableId = joinTableId;
                }
                // Clean joinTable param but keep tableId if exists
                const url = new URL(window.location);
                url.searchParams.delete('joinTable');
                window.history.replaceState({}, document.title, url);
            }
        }

        async function joinTable(tableId) {
            if (!currentUser) return;

            // Check if already a player
            const { data: existing } = await supabase
                .from('table_players')
                .select('*')
                .eq('table_id', tableId)
                .eq('user_id', currentUser.id)
                .single();

            if (!existing) {
                // Add user as player
                const { error } = await supabase
                    .from('table_players')
                    .insert([{
                        table_id: tableId,
                        user_id: currentUser.id,
                        rebuys: 1,
                        food_credit: 0,
                        food_debt: 0
                    }]);

                if (error) {
                    console.error('Error joining table:', error);
                    alert(currentLanguage === 'he' ? '×©×’×™××” ×‘×”×¦×˜×¨×¤×•×ª ×œ×©×•×œ×—×Ÿ' : 'Error joining table');
                } else {
                    openTable(tableId);
                }
            } else {
                openTable(tableId);
            }
        }

        // --- REALTIME SUBSCRIPTIONS ---
        function setupRealtimeForTable(tableId) {
            // Unsubscribe from previous table if exists
            if (realtimeChannels[tableId]) {
                console.log('Unsubscribing from previous channel for table:', tableId);
                realtimeChannels[tableId].unsubscribe();
                delete realtimeChannels[tableId];
            }

            console.log('Setting up realtime for table:', tableId);

            // Subscribe to table_players changes (INSERT, UPDATE, DELETE)
            const channel = supabase
                .channel(`table:${tableId}`, {
                    config: {
                        broadcast: { self: true }
                    }
                })
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'table_players',
                    filter: `table_id=eq.${tableId}`
                }, (payload) => {
                    console.log('ğŸŸ¢ INSERT - Table player added:', payload);
                    if (activeTableId === tableId) {
                        renderTable();
                    }
                })
                .on('postgres_changes', {
                    event: 'UPDATE',
                    schema: 'public',
                    table: 'table_players',
                    filter: `table_id=eq.${tableId}`
                }, (payload) => {
                    console.log('ğŸŸ¡ UPDATE - Table player updated:', payload);
                    if (activeTableId === tableId) {
                        renderTable();
                    }
                })
                .on('postgres_changes', {
                    event: 'DELETE',
                    schema: 'public',
                    table: 'table_players',
                    filter: `table_id=eq.${tableId}`
                }, (payload) => {
                    console.log('ğŸ”´ DELETE - Table player removed:', payload);
                    if (activeTableId === tableId) {
                        renderTable();
                    }
                })
                .on('postgres_changes', {
                    event: '*',
                    schema: 'public',
                    table: 'tables',
                    filter: `id=eq.${tableId}`
                }, (payload) => {
                    console.log('ğŸ“Š Table metadata changed:', payload);
                    if (activeTableId === tableId) {
                        renderTable();
                    }
                })
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'game_logs',
                    filter: `table_id=eq.${tableId}`
                }, (payload) => {
                    console.log('ğŸ“ New game log inserted:', payload);
                    if (activeTableId === tableId) {
                        // Add the new log to the UI immediately
                        addLogToUI(payload.new);
                        // Also refresh the full list to be safe
                        renderGameLogs();
                    }
                })
                .subscribe((status) => {
                    console.log('Realtime subscription status:', status);
                    if (status === 'SUBSCRIBED') {
                        console.log('âœ… Successfully subscribed to realtime for table:', tableId);
                    } else if (status === 'CHANNEL_ERROR') {
                        console.error('âŒ Realtime channel error for table:', tableId);
                    } else if (status === 'TIMED_OUT') {
                        console.warn('â±ï¸ Realtime subscription timed out for table:', tableId);
                    } else if (status === 'CLOSED') {
                        console.log('ğŸ”’ Realtime channel closed for table:', tableId);
                    }
                });

            realtimeChannels[tableId] = channel;
        }

        // Helper function to add new log to UI immediately
        function addLogToUI(logData) {
            const logsList = document.getElementById('gameLogsList');
            if (!logsList) return;

            // If logs container is hidden, don't add (will be added when shown)
            const container = document.getElementById('gameLogsContainer');
            if (container && container.classList.contains('hidden')) {
                return;
            }

            // Create new log item
            const logItem = document.createElement('div');
            logItem.className = 'game-log-item';
            const time = new Date(logData.created_at).toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' });
            logItem.innerHTML = `
                <span class="game-log-time">${time}</span>
                <span>${logData.action_description}</span>
            `;
            
            // Insert at the top of the list
            if (logsList.firstChild) {
                logsList.insertBefore(logItem, logsList.firstChild);
            } else {
                logsList.appendChild(logItem);
            }

            // Remove old logs if more than 20
            while (logsList.children.length > 20) {
                logsList.removeChild(logsList.lastChild);
            }
        }

        // --- URL MANAGEMENT ---
        function updateURL(tableId = null) {
            const url = new URL(window.location);
            if (tableId) {
                url.searchParams.set('tableId', tableId);
                console.log('âœ… Updating URL with tableId:', tableId);
            } else {
                url.searchParams.delete('tableId');
                console.log('ğŸ—‘ï¸ Removing tableId from URL');
            }
            // Use pushState to update URL without page refresh
            window.history.pushState({ tableId }, document.title, url);
            console.log('Current URL:', window.location.href);
        }

        function clearTableFromURL() {
            const url = new URL(window.location);
            url.searchParams.delete('tableId');
            console.log('ğŸ—‘ï¸ Clearing tableId from URL');
            window.history.pushState({}, document.title, url);
        }

        function getTableIdFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const tableId = urlParams.get('tableId');
            console.log('ğŸ” Getting tableId from URL:', tableId);
            
            // Validate that it's a valid UUID (if it exists)
            if (tableId) {
                if (tableId === 'null' || 
                    tableId === 'undefined' || 
                    !UUID_REGEX.test(tableId)) {
                    console.warn('âš ï¸ Invalid tableId in URL:', tableId);
                    // Clear invalid tableId from URL
                    clearTableFromURL();
                    return null;
                }
            }
            
            return tableId;
        }

        // Handle browser back/forward buttons
        window.addEventListener('popstate', (event) => {
            const tableId = getTableIdFromURL();
            if (tableId && currentUser) {
                // User navigated back to a table URL
                openTable(tableId);
            } else if (!tableId && activeTableId) {
                // User navigated away from table
                activeTableId = null;
                showLobby();
            }
        });

        // --- NAVIGATION ---
        function showAuth() {
            hideAllViews();
            document.getElementById('view-auth').classList.remove('hidden');
            document.getElementById('backBtn').style.visibility = 'hidden';
            document.getElementById('userMenu').style.display = 'none';
            // Language toggle button is always visible in header
            clearTableFromURL();
        }

        function showLobby() {
            // Don't clear URL if we're in the middle of loading a table
            const tableIdFromURL = getTableIdFromURL();
            if (!tableIdFromURL) {
                clearTableFromURL();
            }
            
            hideAllViews();
            document.getElementById('view-lobby').classList.remove('hidden');
            document.getElementById('backBtn').style.visibility = 'hidden';
            // Show user menu, language toggle button is always visible in header
            const userMenu = document.getElementById('userMenu');
            if (userMenu) userMenu.style.display = 'flex';
            renderLobby();
        }

        function showMyStats() {
            hideAllViews();
            document.getElementById('view-my-stats').classList.remove('hidden');
            document.getElementById('backBtn').style.visibility = 'visible';
            renderMyStats();
        }

        async function openTable(id) {
            // Validate table ID - must be a valid UUID
            if (!id || 
                id === null || 
                id === 'null' || 
                id === 'undefined' ||
                typeof id !== 'string' ||
                !UUID_REGEX.test(id)) {
                console.error('âŒ Invalid table ID provided to openTable:', id);
                console.error('Type:', typeof id);
                alert('×©×’×™××”: ××–×”×” ×©×•×œ×—×Ÿ ×œ× ×ª×§×™×Ÿ');
                return;
            }

            console.log('âœ… Opening table with valid ID:', id);
            activeTableId = id;
            
            // Update URL without page refresh
            updateURL(id);
            
            hideAllViews();
            document.getElementById('view-table').classList.remove('hidden');
            document.getElementById('backBtn').style.visibility = 'visible';
            setupRealtimeForTable(id);
            
            try {
                await renderTable();
                await renderHallOfFame();
                await renderGameLogs();
            } catch (error) {
                console.error('Error opening table:', error);
                // If table doesn't exist or error, show error but keep URL
                // Only clear URL if it's a real "not found" error
                const errorMessage = error.message || '';
                if (errorMessage.includes('×œ× × ××¦×') || errorMessage.includes('not found')) {
                    clearTableFromURL();
                }
                showLobby();
                alert(t('tableNotFound') + (currentLanguage === 'he' ? ' ××• ××™×Ÿ ×”×¨×©××” ×œ×’×©×ª ××œ×™×•' : ' or no permission to access it'));
            }
        }

        function goBack() {
            if (!document.getElementById('view-settle').classList.contains('hidden')) {
                document.getElementById('view-settle').classList.add('hidden');
                document.getElementById('view-table').classList.remove('hidden');
                renderTable();
                renderHallOfFame();
            } else if (!document.getElementById('view-my-stats').classList.contains('hidden')) {
                showLobby();
            } else {
                // Going back from table view - clear URL and go to lobby
                clearTableFromURL();
                activeTableId = null;
                showLobby();
            }
        }

        function hideAllViews() {
            ['view-loading', 'view-auth', 'view-lobby', 'view-table', 'view-settle', 'view-my-stats', 'view-summary'].forEach(id => {
                document.getElementById(id).classList.add('hidden');
            });
        }

        function showLoading() {
            hideAllViews();
            document.getElementById('view-loading').classList.remove('hidden');
        }

        // --- LOBBY TABS ---
        function switchLobbyTab(tab) {
            document.getElementById('tab-active-games').classList.toggle('active', tab === 'active');
            document.getElementById('tab-history').classList.toggle('active', tab === 'history');
            
            document.getElementById('lobby-active-view').classList.toggle('hidden', tab !== 'active');
            document.getElementById('lobby-history-view').classList.toggle('hidden', tab !== 'history');
            
            if (tab === 'active') {
                renderLobby();
            } else {
                renderHistory();
            }
        }

        async function renderHistory() {
            // History now only shows deleted tables
            await renderDeletedTables();
        }

        async function renderDeletedTables() {
            const container = document.getElementById('deletedTablesContainer');
            container.innerHTML = `<div class="loading">${t('loadingDeleted')}</div>`;

            try {
                // Get deleted tables where user is owner
                const { data: ownedDeletedTables, error: ownedError } = await supabase
                    .from('tables')
                    .select('*')
                    .eq('owner_id', currentUser.id)
                    .eq('is_deleted', true)
                    .order('created_at', { ascending: false });

                if (ownedError) throw ownedError;

                // Get deleted tables where user is a player
                const { data: playerTables, error: playerError } = await supabase
                    .from('table_players')
                    .select('table_id, tables(*)')
                    .eq('user_id', currentUser.id);

                if (playerError) throw playerError;

                // Combine and deduplicate deleted tables
                const tableMap = new Map();
                ownedDeletedTables?.forEach(t => tableMap.set(t.id, t));
                playerTables?.forEach(tp => {
                    if (tp.tables && tp.tables.is_deleted) {
                        tableMap.set(tp.tables.id, tp.tables);
                    }
                });

                const deletedTables = Array.from(tableMap.values());

                container.innerHTML = '';

                if (!deletedTables || deletedTables.length === 0) {
                    container.innerHTML = `<div style="text-align:center; padding:20px; color:#666;">${t('noDeletedTables')}</div>`;
                    return;
                }

                // Get player counts for each table
                for (const table of deletedTables) {
                    const { count } = await supabase
                        .from('table_players')
                        .select('*', { count: 'exact', head: true })
                        .eq('table_id', table.id);
                    table.playerCount = count || 0;
                }

                deletedTables.forEach(table => {
                    const date = new Date(table.created_at).toLocaleDateString('he-IL');
                    const div = document.createElement('div');
                    div.className = 'card';
                    div.style.opacity = '0.7'; // Dim deleted games more
                    div.style.marginBottom = '10px';
                    div.style.borderColor = 'var(--red)';
                    const playersText = currentLanguage === 'he' ? '×©×—×§× ×™×' : 'players';
                    div.innerHTML = `
                        <div style="flex: 1;">
                            <div class="card-title">${table.name} <span style="margin-right: 5px;">ğŸ—‘ï¸</span></div>
                            <div style="color:#888;">${t('entry')}: ${table.buy_in}â‚ª | ${table.playerCount || 0} ${playersText} | ${date}</div>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button class="btn-outline" onclick="viewGameSummary('${table.id}')" style="flex: 1;">${t('summary')}</button>
                            <button class="btn-gold" onclick="restoreDeletedTable('${table.id}')" style="flex: 1;">${t('restoreTable')}</button>
                        </div>
                    `;
                    container.appendChild(div);
                });

            } catch (error) {
                console.error('Error loading deleted tables:', error);
                container.innerHTML = `<div style="text-align:center; color:var(--red);">${t('errorLoadingDeleted')}</div>`;
            }
        }

        async function viewGameSummary(tableId) {
            try {
                // Fetch table details
                const { data: table } = await supabase
                    .from('tables')
                    .select('*')
                    .eq('id', tableId)
                    .single();
                    
                document.getElementById('activeTableName').innerText = table.name; // Hack to reuse element for summary name

                // Fetch player results from this table
                const { data: players } = await supabase
                    .from('table_players')
                    .select('*, profiles(username, phone_number)')
                    .eq('table_id', tableId);

                const results = players.map(p => ({
                    name: p.profiles?.username || t('player'),
                    net: p.net_profit || 0
                }));

                showGameSummary(results);
            } catch (error) {
                console.error('Error viewing summary:', error);
                alert(t('errorLoadingSummary'));
            }
        }

        async function deleteTableFromView() {
            if (!activeTableId) {
                alert(t('noActiveTableToDelete'));
                return;
            }
            await deleteTable(activeTableId);
            // After deletion, return to lobby
            showLobby();
        }

        async function deleteTable(tableId) {
            try {
                // Validate table ID
                if (!tableId || 
                    tableId === null || 
                    tableId === 'null' || 
                    tableId === 'undefined' ||
                    typeof tableId !== 'string' ||
                    !UUID_REGEX.test(tableId)) {
                    console.error('âŒ Invalid table ID provided to deleteTable:', tableId);
                    alert(t('invalidTableId'));
                    return;
                }

                // Confirm deletion
                if (!confirm(t('confirmDelete'))) {
                    return;
                }

                console.log('ğŸ—‘ï¸ Soft deleting table:', tableId);

                // Update table to set is_deleted = true (soft delete)
                const { error: updateError } = await supabase
                    .from('tables')
                    .update({ is_deleted: true })
                    .eq('id', tableId);

                if (updateError) {
                    console.error('âŒ Error deleting table:', updateError);
                    alert(t('errorDeletingTable') + ': ' + updateError.message);
                    return;
                }

                console.log('âœ… Table soft deleted successfully');

                showToast('×”×©×•×œ×—×Ÿ × ××—×§ ×•×¢×‘×¨ ×œ××¨×›×™×•×Ÿ');

            } catch (error) {
                console.error('Error in deleteTable:', error);
                alert(t('errorDeletingTable') + ': ' + error.message);
            }
        }

        async function restoreDeletedTable(tableId) {
            try {
                // Validate table ID
                if (!tableId || 
                    tableId === null || 
                    tableId === 'null' || 
                    tableId === 'undefined' ||
                    typeof tableId !== 'string' ||
                    !UUID_REGEX.test(tableId)) {
                    console.error('âŒ Invalid table ID provided to restoreDeletedTable:', tableId);
                    alert(t('invalidTableId'));
                    return;
                }

                console.log('ğŸ”„ Restoring deleted table:', tableId);

                // Update table to set is_deleted = false and is_active = true
                const { error: updateError } = await supabase
                    .from('tables')
                    .update({ is_deleted: false, is_active: true })
                    .eq('id', tableId);

                if (updateError) {
                    console.error('âŒ Error restoring deleted table:', updateError);
                    alert(t('errorRestoringTable') + ': ' + updateError.message);
                    return;
                }

                console.log('âœ… Deleted table restored successfully');

                // Refresh both lobby and history views
                await renderLobby();
                await renderHistory();

                // If we're in the history view, switch to active tab to show the restored table
                const currentTab = document.getElementById('tab-history').classList.contains('active') ? 'history' : 'active';
                if (currentTab === 'history') {
                    switchLobbyTab('active');
                }

                showToast('×”×©×•×œ×—×Ÿ ×©×•×—×–×¨ ×‘×”×¦×œ×—×”');

            } catch (error) {
                console.error('Error in restoreDeletedTable:', error);
                alert(t('errorRestoringTable') + ': ' + error.message);
            }
        }

        async function restoreTable(tableId) {
            try {
                // Validate table ID
                if (!tableId || 
                    tableId === null || 
                    tableId === 'null' || 
                    tableId === 'undefined' ||
                    typeof tableId !== 'string' ||
                    !UUID_REGEX.test(tableId)) {
                    console.error('âŒ Invalid table ID provided to restoreTable:', tableId);
                    alert(t('invalidTableId'));
                    return;
                }

                console.log('ğŸ”„ Restoring table:', tableId);

                // Update table to active
                const { error: updateError } = await supabase
                    .from('tables')
                    .update({ is_active: true })
                    .eq('id', tableId);

                if (updateError) {
                    console.error('âŒ Error restoring table:', updateError);
                    alert(t('errorRestoringTable') + ': ' + updateError.message);
                    return;
                }

                console.log('âœ… Table restored successfully');

                // Immediately open the restored table
                await openTable(tableId);

                // If we're in the history view, switch back to active tab
                // (The table will now appear in active tables, not history)
                const currentTab = document.getElementById('tab-history').classList.contains('active') ? 'history' : 'active';
                if (currentTab === 'history') {
                    // Switch to active tab to show the restored table
                    switchLobbyTab('active');
                }

            } catch (error) {
                console.error('Error in restoreTable:', error);
                alert(t('errorRestoringTable') + ': ' + error.message);
            }
        }

        // --- LOBBY ---
        async function createNewTable() {
            const name = document.getElementById('newTableName').value;
            const buyIn = parseInt(document.getElementById('newTableBuyIn').value);
            if (!name || !buyIn) return alert(t('fillAllFields'));

            try {
                if (!currentUser) {
                    alert(t('notConnected'));
                    return;
                }

                // Step 1: Create the Table
                console.log('ğŸ“‹ Step 1: Creating table...');
                const { data, error } = await supabase
                    .from('tables')
                    .insert([{
                        name: name,
                        buy_in: buyIn,
                        owner_id: currentUser.id,
                        is_active: true
                    }])
                    .select()
                    .single();

                if (error) {
                    console.error('Error creating table:', error);
                    if (error.message.includes('row-level security') || error.message.includes('RLS') || error.message.includes('policy')) {
                        alert(currentLanguage === 'he' ? '×‘×¢×™×™×ª ×”×¨×©××•×ª. ×•×“× ×©×”×¨×¦×ª ××ª fix_all_rls_final.sql ×‘-Supabase SQL Editor.' : 'Permission issue. Make sure you ran fix_all_rls_final.sql in Supabase SQL Editor.');
                    } else {
                        alert(t('errorCreatingTable') + ': ' + error.message);
                    }
                    return;
                }

                if (!data || !data.id) {
                    alert(t('tableCreatedButNoId'));
                    return;
                }

                const tableId = data.id;
                console.log('âœ… Step 1: Table created with ID:', tableId);

                // Step 2: Add Host as Player
                console.log('ğŸ‘¤ Step 2: Adding host as player...');
                const { error: playerError } = await supabase
                    .from('table_players')
                    .insert([{
                        table_id: tableId,
                        user_id: currentUser.id,
                        rebuys: 1, // Automatically register 1 buy-in
                        food_credit: 0,
                        food_debt: 0
                    }]);

                if (playerError) {
                    console.error('âŒ Error adding host as player:', playerError);
                    // If adding player fails, we should still show success but warn
                    alert(t('tableCreatedSuccess'));
                } else {
                    console.log('âœ… Step 2: Host added as player with 1 buy-in');
                }

                // Step 3: Add game log for player addition
                try {
                    await supabase
                        .from('game_logs')
                        .insert([{
                            table_id: tableId,
                            action: 'player_added',
                            message: `${currentUser.user_metadata?.username || '×”×××¨×—'} ×”×¦×˜×¨×£ ×œ×©×•×œ×—×Ÿ (buy-in ×¨××©×•×Ÿ)`,
                            user_id: currentUser.id
                        }]);
                    console.log('âœ… Step 3: Game log created');
                } catch (logError) {
                    console.warn('âš ï¸ Could not create game log:', logError);
                    // Non-critical, continue
                }

                // Close modal and clear form
                closeModal('modal-create');
                document.getElementById('newTableName').value = '';
                document.getElementById('newTableBuyIn').value = '';
                
                // Direct entry to game - open the table immediately
                console.log('ğŸ® Opening table directly...');
                await openTable(tableId);
                
            } catch (error) {
                console.error('Error in createNewTable:', error);
                alert(t('errorCreatingTable') + ': ' + (error.message || (currentLanguage === 'he' ? '×©×’×™××” ×œ× ×™×“×•×¢×”' : 'Unknown error')));
            }
        }

        async function renderLobby() {
            const container = document.getElementById('tablesListContainer');
            container.innerHTML = `<div class="loading">${t('loading')}</div>`;

            try {
                // Get all tables where user is owner (active tables only)
                // Persistent Club Model: Tables remain visible after finishing games
                const { data: ownedTables, error: ownedError } = await supabase
                    .from('tables')
                    .select('*')
                    .eq('owner_id', currentUser.id)
                    .eq('is_active', true);

                if (ownedError) {
                    console.error('Error loading owned tables:', ownedError);
                    throw ownedError;
                }

                // Get tables where user is a player
                const { data: playerTables, error: playerError } = await supabase
                    .from('table_players')
                    .select('table_id, tables(*)')
                    .eq('user_id', currentUser.id);

                if (playerError) {
                    console.error('Error loading player tables:', playerError);
                    throw playerError;
                }

                // Combine and deduplicate, filtering out deleted tables
                const tableMap = new Map();
                const seenIds = new Set(); // Track IDs to prevent duplicates
                
                // Add owned tables (only if not deleted and active)
                ownedTables?.forEach(t => {
                    if (t && 
                        t.id && 
                        !seenIds.has(t.id) &&
                        t.is_active === true &&
                        (t.is_deleted === false || t.is_deleted === null || t.is_deleted === undefined)) {
                        tableMap.set(t.id, t);
                        seenIds.add(t.id);
                    }
                });
                
                // Add tables where user is a player (only if active and not deleted)
                // Skip if already added as owned table
                playerTables?.forEach(tp => {
                    if (tp.tables && 
                        tp.tables.id &&
                        !seenIds.has(tp.tables.id) &&
                        tp.tables.is_active === true && 
                        (tp.tables.is_deleted === false || tp.tables.is_deleted === null || tp.tables.is_deleted === undefined)) {
                        tableMap.set(tp.tables.id, tp.tables);
                        seenIds.add(tp.tables.id);
                    }
                });

                // Convert to array and ensure no duplicates (safety net)
                const activeTables = Array.from(tableMap.values());
                const finalTableMap = new Map();
                activeTables.forEach(table => {
                    if (table && table.id && !finalTableMap.has(table.id)) {
                        finalTableMap.set(table.id, table);
                    }
                });
                
                const uniqueTables = Array.from(finalTableMap.values());

                container.innerHTML = '';
            if (uniqueTables.length === 0) {
                container.innerHTML = `<div style="text-align:center; color:#666;">${t('noActiveTables')}</div>`;
                return;
            }

                // Get player counts
                for (const table of uniqueTables) {
                    const { count } = await supabase
                        .from('table_players')
                        .select('*', { count: 'exact', head: true })
                        .eq('table_id', table.id);
                    table.playerCount = count || 0;
            }

            uniqueTables.forEach(table => {
                if (!table || !table.id) return; // Skip invalid tables
                
                const div = document.createElement('div');
                div.className = 'card';
                div.style.cursor = 'pointer';
                div.innerHTML = `
                    <div class="card-title">${table.name}</div>
                    <div style="color:#888;">${t('entry')}: ${table.buy_in}â‚ª | ${table.playerCount || 0} ${currentLanguage === 'he' ? '×©×—×§× ×™×' : 'players'}</div>
                `;
                div.onclick = () => openTable(table.id);
                container.appendChild(div);
            });
            } catch (error) {
                container.innerHTML = '<div style="text-align:center; color:var(--red);">×©×’×™××” ×‘×˜×¢×™× ×ª ×©×•×œ×—× ×•×ª</div>';
                console.error('Error loading tables:', error);
            }
        }

        // --- MY STATS ---
        async function renderMyStats() {
            const container = document.getElementById('myStatsContent');
            container.innerHTML = `<div class="loading">${t('loadingData')}</div>`;

            console.log('=== RENDERING MY STATS ===');
            console.log('Current user ID:', currentUser.id);

            try {
                // Get profile stats (updated by trigger)
                const { data: profile, error: profileError } = await supabase
                    .from('profiles')
                    .select('total_profit, games_played')
                    .eq('id', currentUser.id)
                    .single();

                console.log('Profile data:', profile);
                console.log('Profile error:', profileError);

                if (profileError) throw profileError;

                // Get all game results for best/worst game
                const { data: results, error } = await supabase
                    .from('game_results')
                    .select('*')
                    .eq('user_id', currentUser.id);

                console.log('Game results:', results);

                if (error) throw error;

                let maxWin = null;
                let maxLoss = null;

                results?.forEach(result => {
                    if (result.net_profit > 0 && (!maxWin || result.net_profit > maxWin.net_profit)) {
                        maxWin = result;
                    }
                    if (result.net_profit < 0 && (!maxLoss || result.net_profit < maxLoss.net_profit)) {
                        maxLoss = result;
                    }
                });

                const totalNet = profile.total_profit || 0;
                const totalGames = profile.games_played || 0;
                const sign = totalNet > 0 ? '+' : '';

                console.log('Total profit:', totalNet);
                console.log('Total games:', totalGames);

                container.innerHTML = `
                    <div style="text-align:center; margin-bottom:20px;">
                        <div style="font-size:2rem; font-weight:bold; color:var(--gold); margin-bottom:10px; direction:ltr; text-align:center;">
                            ${sign}${Math.round(totalNet)}â‚ª
                        </div>
                        <div style="color:var(--gray);">${t('totalProfitLoss')} ${t('allTime')}</div>
                    </div>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
                        <div class="hof-stat">
                            <div class="hof-stat-title">${t('gamesPlayed')}</div>
                            <div class="hof-stat-value">${totalGames}</div>
                        </div>
                        <div class="hof-stat">
                            <div class="hof-stat-title">${t('averagePerGame')}</div>
                            <div class="hof-stat-value" style="direction:ltr; text-align:center;">${totalGames > 0 ? Math.round(totalNet / totalGames) : 0}â‚ª</div>
                        </div>
                    </div>
                    ${maxWin ? `
                        <div class="hof-stat">
                            <div class="hof-stat-title">${t('biggestWin')} <span style="margin-right: 5px;">ğŸ¦ˆ</span></div>
                            <div class="hof-stat-value" style="color:var(--green); direction:ltr; text-align:center;">+${Math.round(maxWin.net_profit)}â‚ª</div>
                        </div>
                    ` : ''}
                    ${maxLoss ? `
                        <div class="hof-stat">
                            <div class="hof-stat-title">${t('biggestLoss')} <span style="margin-right: 5px;">ğŸ‘</span></div>
                            <div class="hof-stat-value" style="color:var(--red); direction:ltr; text-align:center;">${Math.round(maxLoss.net_profit)}â‚ª</div>
                        </div>
                    ` : ''}
                `;
                
                console.log('My Stats rendered successfully');
            } catch (error) {
                container.innerHTML = `<div style="text-align:center; color:var(--red);">${t('errorLoadingStats')}: ${error.message}</div>`;
                console.error('Error loading stats:', error);
            }
        }

        // --- ACTIVE TABLE ---
        async function renderTable() {
            try {
                // Validate activeTableId - must be a valid UUID, not null or "null"
                if (!activeTableId || 
                    activeTableId === null || 
                    activeTableId === 'null' || 
                    activeTableId === 'undefined' ||
                    typeof activeTableId !== 'string' ||
                    !UUID_REGEX.test(activeTableId)) {
                    console.error('âŒ Invalid active table ID:', activeTableId);
                    console.error('Type:', typeof activeTableId);
                    console.error('Is null:', activeTableId === null);
                    console.error('Is "null":', activeTableId === 'null');
                    // Clear invalid table ID and return to lobby
                    activeTableId = null;
                    clearTableFromURL();
                    showLobby();
                    return;
                }

                console.log('âœ… Valid active table ID:', activeTableId);

                const { data: table, error: tableError } = await supabase
                    .from('tables')
                    .select('*')
                    .eq('id', activeTableId)
                    .single();

                if (tableError) {
                    console.error('Error fetching table:', tableError);
                    throw new Error('×œ× × ×™×ª×Ÿ ×œ×˜×¢×•×Ÿ ××ª ×”×©×•×œ×—×Ÿ: ' + tableError.message);
                }

                if (!table) {
                    throw new Error('×©×•×œ×—×Ÿ ×œ× × ××¦×');
                }

                document.getElementById('activeTableName').innerText = table.name;
                document.getElementById('activeBuyIn').innerText = table.buy_in + 'â‚ª';
                
                // Store buy_in for optimistic updates
                currentTableBuyIn = table.buy_in;

                // Show delete button only if user is the owner
                const deleteBtn = document.getElementById('btnDeleteTable');
                if (deleteBtn) {
                    if (table.owner_id === currentUser.id) {
                        deleteBtn.style.display = 'block';
                    } else {
                        deleteBtn.style.display = 'none';
                    }
                }

                // Get players
                const { data: players, error: playersError } = await supabase
                    .from('table_players')
                    .select('*, profiles(username)')
                    .eq('table_id', activeTableId);

                if (playersError) {
                    console.error('Error fetching players:', playersError);
                    console.error('Full error details:', JSON.stringify(playersError, null, 2));
                    console.error('Current user ID:', currentUser?.id);
                    console.error('Active table ID:', activeTableId);
                    
                    // If it's RLS error, show helpful message with more details
                    if (playersError.message.includes('row-level security') || playersError.message.includes('RLS') || playersError.message.includes('policy') || playersError.code === '42501') {
                        const detailedError = `×‘×¢×™×™×ª ×”×¨×©××•×ª RLS.\n\n×¤×¨×˜×™×:\n- ×§×•×“ ×©×’×™××”: ${playersError.code || '×œ× ×™×“×•×¢'}\n- ×”×•×“×¢×”: ${playersError.message}\n- ××©×ª××©: ${currentUser?.id || '×œ× ××—×•×‘×¨'}\n- ×©×•×œ×—×Ÿ: ${activeTableId || '×œ× × ×‘×—×¨'}\n\n×× × ×”×¨×¥ ××ª quick_fix_rls.sql ×‘-Supabase SQL Editor.`;
                        throw new Error(detailedError);
                    }
                    throw playersError;
                }
            
            let pot = 0;
            const list = document.getElementById('activePlayersList');
                if (!list) {
                    console.error('activePlayersList element not found');
                    return;
                }
            list.innerHTML = '';

                if (players && players.length > 0) {
                    // Sort players by rebuys (descending) - highest buy-ins first
                    const sortedPlayers = [...players].sort((a, b) => {
                        const rebuysA = a.rebuys || 1;
                        const rebuysB = b.rebuys || 1;
                        return rebuysB - rebuysA; // Descending order
                    });
                    
                    sortedPlayers.forEach(p => {
                        const invested = (p.rebuys || 1) * table.buy_in;
                pot += invested;
                
                const div = document.createElement('div');
                div.className = 'player-row';
                div.setAttribute('data-player-id', p.id);
                div.setAttribute('data-rebuys', p.rebuys || 1);
                        const playerName = p.profiles?.username || t('player');
                div.innerHTML = `
                    <div>
                                <div style="font-weight:bold;">${playerName}</div>
                        <div style="font-size:0.8rem; color:#888;">${t('invested')}: ${invested}â‚ª</div>
                    </div>
                    <div style="display:flex; align-items:center; gap:10px;">
                                <button class="rebuy-btn" onclick="removeRebuy('${p.id}')" ${(p.rebuys || 1) <= 1 ? 'disabled' : ''}>-</button>
                                <span class="rebuy-count" style="font-size:0.9rem;">${p.rebuys || 1}</span>
                                <button class="rebuy-btn" onclick="addRebuy('${p.id}')">+</button>
                    </div>
                `;
                list.appendChild(div);
            });
                } else {
                    list.innerHTML = `<div style="text-align:center; color:#666; padding:10px;">${currentLanguage === 'he' ? '××™×Ÿ ×©×—×§× ×™× ×¢×“×™×™×Ÿ' : 'No players yet'}</div>`;
                }

                const potElement = document.getElementById('activePot');
                if (potElement) {
                    potElement.innerText = pot + 'â‚ª';
                }
            } catch (error) {
                console.error('Error rendering table:', error);
                const errorMsg = error.message || '×©×’×™××” ×‘×˜×¢×™× ×ª ×”×©×•×œ×—×Ÿ';
                alert(errorMsg);
                // Go back to lobby on error
                showLobby();
            }
        }

        async function addPlayer() {
            const name = document.getElementById('newPlayerName').value;
            if(!name) return;

            try {
                // Find user by username
                const { data: profile } = await supabase
                    .from('profiles')
                    .select('id')
                    .eq('username', name)
                    .single();

                if (!profile) {
                    alert(t('userNotFound'));
                    return;
                }

                // Check if already a player
                const { data: existing } = await supabase
                    .from('table_players')
                    .select('*')
                    .eq('table_id', activeTableId)
                    .eq('user_id', profile.id)
                    .single();

                if (existing) {
                    alert(t('playerAlreadyInTable'));
                    return;
                }

                const { error } = await supabase
                    .from('table_players')
                    .insert([{
                        table_id: activeTableId,
                        user_id: profile.id,
                rebuys: 1,
                        food_credit: 0,
                        food_debt: 0
                    }]);

                if (error) throw error;

                // Add game log
                await addGameLog(
                    'player_added',
                    `${name} ×”×¦×˜×¨×£ ×œ×©×•×œ×—×Ÿ`
                );

            document.getElementById('newPlayerName').value = '';
            closeModal('modal-add-player');
            await renderTable();
            // Refresh Hall of Fame to show the new player immediately (with 0 profit)
            await renderHallOfFame();
            } catch (error) {
                alert(t('errorAddingPlayer') + ': ' + error.message);
            }
        }

        // --- GAME LOGS ---
        async function addGameLog(actionType, actionDescription, oldValue = null, newValue = null) {
            try {
                const { error } = await supabase
                    .from('game_logs')
                    .insert([{
                        table_id: activeTableId,
                        user_id: currentUser.id,
                        action_type: actionType,
                        action_description: actionDescription,
                        old_value: oldValue,
                        new_value: newValue
                    }]);

                if (error) {
                    console.error('Error adding game log:', error);
                }
            } catch (error) {
                console.error('Error adding game log:', error);
            }
        }

        async function renderGameLogs() {
            const logsList = document.getElementById('gameLogsList');
            if (!logsList) return;

            try {
                const { data: logs, error } = await supabase
                    .from('game_logs')
                    .select('*, profiles(username)')
                    .eq('table_id', activeTableId)
                    .order('created_at', { ascending: false })
                    .limit(20);

                if (error) throw error;

                if (!logs || logs.length === 0) {
                    logsList.innerHTML = `<div style="text-align:center; color:#666; padding:10px;">${currentLanguage === 'he' ? '××™×Ÿ ×¤×¢×™×œ×•×ª ×¢×“×™×™×Ÿ' : 'No activity yet'}</div>`;
                    return;
                }

                logsList.innerHTML = '';
                logs.forEach(log => {
                    const logItem = document.createElement('div');
                    logItem.className = 'game-log-item';
                    const time = new Date(log.created_at).toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' });
                    logItem.innerHTML = `
                        <span class="game-log-time">${time}</span>
                        <span>${log.action_description}</span>
                    `;
                    logsList.appendChild(logItem);
                });
            } catch (error) {
                console.error('Error rendering game logs:', error);
                logsList.innerHTML = '<div style="text-align:center; color:var(--red); padding:10px;">×©×’×™××” ×‘×˜×¢×™× ×ª ×œ×•×’×™×</div>';
            }
        }

        function toggleGameLogs() {
            const container = document.getElementById('gameLogsContainer');
            container.classList.toggle('hidden');
            if (!container.classList.contains('hidden')) {
                renderGameLogs();
            }
        }

        async function addRebuy(playerId) {
            try {
                // Get current player data
                const { data: player, error: fetchError } = await supabase
                    .from('table_players')
                    .select('rebuys, profiles(username)')
                    .eq('id', playerId)
                    .single();

                if (fetchError) throw fetchError;

                const oldRebuys = player.rebuys || 1;
                const newRebuys = oldRebuys + 1;
                const playerName = player.profiles?.username || '×©×—×§×Ÿ';

                // OPTIMISTIC UI: Update immediately
                updateRebuyDisplay(playerId, newRebuys);

                // Get table buy_in for log
                const { data: table } = await supabase
                    .from('tables')
                    .select('buy_in')
                    .eq('id', activeTableId)
                    .single();

                const buyInAmount = table?.buy_in || 0;
                const amountAdded = buyInAmount;

                // Update in database
                const { error: updateError } = await supabase
                    .from('table_players')
                    .update({ rebuys: newRebuys })
                    .eq('id', playerId);

                if (updateError) {
                    // Rollback on error
                    updateRebuyDisplay(playerId, oldRebuys);
                    throw updateError;
                }

                // Add game log
                await addGameLog(
                    'rebuy_add',
                    `${playerName} ×”×•×¡×™×£ ${amountAdded}â‚ª`,
                    oldRebuys,
                    newRebuys
                );

                // Realtime will sync with other users
                // Note: Debounced sort will trigger automatically via updateRebuyDisplay
            } catch (error) {
                console.error('Error adding rebuy:', error);
                // Re-render to get correct state on error
                renderTable();
            }
        }

        async function removeRebuy(playerId) {
            try {
                // Get current player data
                const { data: player, error: fetchError } = await supabase
                    .from('table_players')
                    .select('rebuys, profiles(username)')
                    .eq('id', playerId)
                    .single();

                if (fetchError) throw fetchError;

                const oldRebuys = player.rebuys || 1;
                if (oldRebuys <= 1) return;

                const newRebuys = oldRebuys - 1;
                const playerName = player.profiles?.username || '×©×—×§×Ÿ';

                // OPTIMISTIC UI: Update immediately
                updateRebuyDisplay(playerId, newRebuys);

                // Get table buy_in for log
                const { data: table } = await supabase
                    .from('tables')
                    .select('buy_in')
                    .eq('id', activeTableId)
                    .single();

                const buyInAmount = table?.buy_in || 0;
                const amountRemoved = buyInAmount;

                // Update in database
                const { error: updateError } = await supabase
                    .from('table_players')
                    .update({ rebuys: newRebuys })
                    .eq('id', playerId);

                if (updateError) {
                    // Rollback on error
                    updateRebuyDisplay(playerId, oldRebuys);
                    throw updateError;
                }

                // Add game log
                await addGameLog(
                    'rebuy_remove',
                    `${playerName} ×”×•×¨×™×“ ${amountRemoved}â‚ª`,
                    oldRebuys,
                    newRebuys
                );

                // Realtime will sync with other users
                // Note: Debounced sort will trigger automatically via updateRebuyDisplay
            } catch (error) {
                console.error('Error removing rebuy:', error);
                // Re-render to get correct state on error
                renderTable();
            }
        }

        // Store current table buy_in for optimistic updates
        let currentTableBuyIn = 0;

        // Helper function for Optimistic UI update
        function updateRebuyDisplay(playerId, newRebuys) {
            const list = document.getElementById('activePlayersList');
            if (!list) return;
            
            const playerRows = list.querySelectorAll('.player-row');
            let foundPlayer = false;
            
            playerRows.forEach(row => {
                const buttons = row.querySelectorAll('button');
                const span = row.querySelector('span.rebuy-count');
                
                // Check if this is the right player (by data attribute)
                if (row.getAttribute('data-player-id') === playerId) {
                    foundPlayer = true;
                    if (span) {
                        span.textContent = newRebuys;
                    }
                    // Update data attribute for sorting
                    row.setAttribute('data-rebuys', newRebuys);
                    
                    // Update disable state for minus button
                    const minusBtn = Array.from(buttons).find(btn => 
                        btn.textContent === '-' && btn.onclick && btn.onclick.toString().includes(`'${playerId}'`)
                    );
                    if (minusBtn) {
                        minusBtn.disabled = newRebuys <= 1;
                    }
                }
            });
            
            // Recalculate pot if we found the player
            if (foundPlayer && currentTableBuyIn > 0) {
                let totalPot = 0;
                playerRows.forEach(r => {
                    const rebuySpan = r.querySelector('span.rebuy-count');
                    if (rebuySpan) {
                        const rebuys = parseInt(rebuySpan.textContent) || 1;
                        totalPot += rebuys * currentTableBuyIn;
                    }
                });
                
                const potElement = document.getElementById('activePot');
                if (potElement) {
                    potElement.innerText = totalPot + 'â‚ª';
                }
            }
            
            // Trigger debounced sort
            triggerDebouncedSort();
        }

        // Debounced sort timer
        let sortTimer = null;

        // Debounced sort function - waits 3 seconds after last click
        function triggerDebouncedSort() {
            // Clear existing timer
            if (sortTimer) {
                clearTimeout(sortTimer);
            }
            
            // Set new timer for 3 seconds
            sortTimer = setTimeout(() => {
                animateSortPlayers();
            }, 3000);
        }

        // Animated sort function - smoothly reorders players by rebuys
        function animateSortPlayers() {
            const list = document.getElementById('activePlayersList');
            if (!list) return;
            
            const playerRows = Array.from(list.querySelectorAll('.player-row'));
            if (playerRows.length <= 1) return; // No need to sort if 0 or 1 player
            
            // Get current positions and rebuys
            const players = playerRows.map(row => ({
                element: row,
                playerId: row.getAttribute('data-player-id'),
                rebuys: parseInt(row.getAttribute('data-rebuys')) || 1
            }));
            
            // Store original positions relative to list
            const listRect = list.getBoundingClientRect();
            const originalPositions = new Map();
            players.forEach((player) => {
                const rect = player.element.getBoundingClientRect();
                originalPositions.set(player.playerId, {
                    top: rect.top - listRect.top,
                    element: player.element
                });
            });
            
            // Sort by rebuys descending
            const sortedPlayers = [...players].sort((a, b) => b.rebuys - a.rebuys);
            
            // Check if order actually changed
            let orderChanged = false;
            for (let i = 0; i < players.length; i++) {
                if (players[i].playerId !== sortedPlayers[i].playerId) {
                    orderChanged = true;
                    break;
                }
            }
            
            if (!orderChanged) {
                return; // No need to animate if order is already correct
            }
            
            // FLIP animation technique: First, Last, Invert, Play
            // 1. FIRST: Record initial positions
            const firstPositions = new Map();
            players.forEach((player) => {
                const rect = player.element.getBoundingClientRect();
                firstPositions.set(player.playerId, {
                    top: rect.top - listRect.top + list.scrollTop,
                    left: rect.left - listRect.left,
                    width: rect.width
                });
            });
            
            // 2. LAST: Reorder DOM and get final positions
            sortedPlayers.forEach((player) => {
                list.appendChild(player.element);
            });
            
            // Force reflow
            void list.offsetHeight;
            
            const lastPositions = new Map();
            const newListRect = list.getBoundingClientRect();
            sortedPlayers.forEach((player) => {
                const rect = player.element.getBoundingClientRect();
                lastPositions.set(player.playerId, {
                    top: rect.top - newListRect.top + list.scrollTop,
                    left: rect.left - newListRect.left
                });
            });
            
            // 3. INVERT: Set transform to create illusion of no movement
            sortedPlayers.forEach((player) => {
                const first = firstPositions.get(player.playerId);
                const last = lastPositions.get(player.playerId);
                
                if (first && last) {
                    const deltaY = first.top - last.top;
                    player.element.style.transition = 'none';
                    player.element.style.transform = `translateY(${deltaY}px)`;
                    player.element.style.opacity = '0.8';
                }
            });
            
            // 4. PLAY: Animate to final positions
            requestAnimationFrame(() => {
                sortedPlayers.forEach((player) => {
                    player.element.style.transition = 'transform 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease-in-out';
                    player.element.style.transform = 'translateY(0)';
                    player.element.style.opacity = '1';
                });
            });
            
            // Clean up after animation
            setTimeout(() => {
                sortedPlayers.forEach((player) => {
                    player.element.style.transform = '';
                    player.element.style.opacity = '';
                    player.element.style.transition = '';
                });
            }, 500);
        }

        // --- HALL OF FAME (Table-specific stats) ---
        function toggleHallOfFame() {
            const content = document.getElementById('hallOfFameContent');
            content.classList.toggle('hidden');
            if (!content.classList.contains('hidden')) {
                renderHallOfFame();
            }
        }

        async function renderHallOfFame() {
            console.log('=== RENDERING HALL OF FAME ===');
            console.log('Table ID:', activeTableId);
            
            try {
                // Get all current players in the table (for immediate leaderboard registration)
                const { data: currentPlayers, error: playersError } = await supabase
                    .from('table_players')
                    .select('user_id, profiles(username)')
                    .eq('table_id', activeTableId);

                if (playersError) {
                    console.error('Error fetching current players:', playersError);
                }

                // Get all game results for this table
                const { data: results, error} = await supabase
                    .from('game_results')
                    .select('*, profiles(username)')
                    .eq('table_id', activeTableId);

                console.log('Hall of Fame query results:', results);
                console.log('Hall of Fame query error:', error);

                if (error) throw error;

                // Initialize tableStats with all current players (for immediate leaderboard registration)
                const tableStats = {};
                
                // First, add all current players with 0 stats (so they appear immediately)
                if (currentPlayers && currentPlayers.length > 0) {
                    currentPlayers.forEach(player => {
                        const username = player.profiles?.username || '×©×—×§×Ÿ';
                        if (player.user_id && !tableStats[player.user_id]) {
                            tableStats[player.user_id] = {
                                username: username,
                                gamesPlayed: 0,
                                net: 0
                            };
                        }
                    });
                }

                let maxWin = null;
                let maxLoss = null;

                // Then, update stats from game results
                if (results && results.length > 0) {
                    console.log(`Found ${results.length} game results`);

                    results.forEach(result => {
                        const username = result.profiles?.username || '×©×—×§×Ÿ';
                        if (!tableStats[result.user_id]) {
                            tableStats[result.user_id] = {
                                username: username,
                                gamesPlayed: 0,
                                net: 0
                            };
                        }
                        tableStats[result.user_id].gamesPlayed++;
                        tableStats[result.user_id].net += result.net_profit || 0;

                        // Track single-game records
                        if (result.net_profit > 0) {
                            if (!maxWin || result.net_profit > maxWin.net_profit) {
                                maxWin = { username: username, net_profit: result.net_profit };
                            }
                        }
                        if (result.net_profit < 0) {
                            if (!maxLoss || result.net_profit < maxLoss.net_profit) {
                                maxLoss = { username: username, net_profit: result.net_profit };
                            }
                        }
                    });
                } else {
                    console.log('No game results found for this table');
                }

                console.log('Shark:', maxWin);
                console.log('Loser:', maxLoss);
                console.log('Table Stats:', tableStats);

                // Display The Shark
                if (maxWin) {
                    document.getElementById('hofShark').innerHTML = 
                        `<span style="color:var(--green);">${maxWin.username}</span>: <span style="direction:ltr; display:inline-block;">+${Math.round(maxWin.net_profit)}â‚ª</span>`;
                } else {
                    document.getElementById('hofShark').innerText = t('noData');
                }

                // Display The Loser (ğŸ‘)
                if (maxLoss) {
                    document.getElementById('hofLoser').innerHTML = 
                        `<span style="color:var(--red);">${maxLoss.username}</span>: <span style="direction:ltr; display:inline-block;">${Math.round(maxLoss.net_profit)}â‚ª</span>`;
                } else {
                    document.getElementById('hofLoser').innerText = t('noData');
                }

                // Display League Table
                const tbody = document.getElementById('tableLeagueTableBody');
                tbody.innerHTML = '';
                
                const sortedPlayers = Object.values(tableStats).sort((a,b) => b.net - a.net);
                
                if (sortedPlayers.length === 0) {
                    tbody.innerHTML = `<tr><td colspan="3" style="text-align:center; color:#666;">${currentLanguage === 'he' ? '××™×Ÿ ×©×—×§× ×™× ×‘×©×•×œ×—×Ÿ' : 'No players in table'}</td></tr>`;
                } else {
                    sortedPlayers.forEach(p => {
                        const colorClass = p.net >= 0 ? 'profit' : 'loss';
                        const sign = p.net > 0 ? '+' : '';
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td><b>${p.username}</b></td>
                            <td style="text-align:center;">${p.gamesPlayed}</td>
                            <td class="${colorClass}" style="direction:ltr; text-align:right;">${sign}${Math.round(p.net)}â‚ª</td>
                        `;
                        tbody.appendChild(row);
                    });
                }
                
                console.log('Hall of Fame rendered successfully');
            } catch (error) {
                console.error('Error rendering Hall of Fame:', error);
                document.getElementById('hofShark').innerText = '×©×’×™××”: ' + error.message;
                document.getElementById('hofLoser').innerText = '×©×’×™××”';
            }
        }

        // --- FOOD LOGIC ---
        function setFoodMode(mode) {
            currentFoodMode = mode;
            document.getElementById('btnSplitEqual').className = mode === 'equal' ? 'toggle-btn active' : 'toggle-btn';
            document.getElementById('btnSplitIndiv').className = mode === 'indiv' ? 'toggle-btn active' : 'toggle-btn';
            
            if(mode === 'equal') {
                document.getElementById('foodModeEqual').classList.remove('hidden');
                document.getElementById('foodModeIndiv').classList.add('hidden');
            } else {
                document.getElementById('foodModeEqual').classList.add('hidden');
                document.getElementById('foodModeIndiv').classList.remove('hidden');
            }
        }

        async function openFoodModal() {
            try {
                const { data: players } = await supabase
                    .from('table_players')
                    .select('*, profiles(username)')
                    .eq('table_id', activeTableId);

                if (!players || players.length === 0) return alert(t('noPlayers'));

            // Populate Payer Select
            const select = document.getElementById('foodPayerSelect');
            select.innerHTML = '';
                players.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                    opt.innerText = p.profiles?.username || '×©×—×§×Ÿ';
                select.appendChild(opt);
            });

            // Populate Checkboxes (Equal Mode)
            const listEq = document.getElementById('foodEatersListEqual');
            listEq.innerHTML = '';
                players.forEach(p => {
                    listEq.innerHTML += `<div style="padding:5px;"><label><input type="checkbox" value="${p.id}" checked> ${p.profiles?.username || '×©×—×§×Ÿ'}</label></div>`;
            });

            // Populate Inputs (Indiv Mode)
            const listInd = document.getElementById('foodEatersListIndiv');
            listInd.innerHTML = '';
                players.forEach(p => {
                listInd.innerHTML += `
                    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:5px;">
                            <label>${p.profiles?.username || '×©×—×§×Ÿ'}</label>
                        <input type="number" class="indiv-amount" data-id="${p.id}" placeholder="×¡×›×•×" style="width:80px; margin:0;">
                    </div>
                `;
            });

            document.getElementById('foodTotalAmount').value = '';
            openModal('modal-food');
            } catch (error) {
                console.error('Error opening food modal:', error);
            }
        }

        async function submitFood() {
            try {
                const payerId = document.getElementById('foodPayerSelect').value;
            let totalAmount = 0;

            if (currentFoodMode === 'equal') {
                totalAmount = parseFloat(document.getElementById('foodTotalAmount').value) || 0;
                const checkboxes = document.querySelectorAll('#foodEatersListEqual input:checked');
                
                if(!totalAmount || checkboxes.length === 0) return alert(t('missingDetails'));
                
                const amountPerPerson = totalAmount / checkboxes.length;
                    for (const cb of checkboxes) {
                        const { data: player } = await supabase
                            .from('table_players')
                            .select('food_debt')
                            .eq('id', cb.value)
                            .single();
                        
                        await supabase
                            .from('table_players')
                            .update({ food_debt: (player.food_debt || 0) + amountPerPerson })
                            .eq('id', cb.value);
                    }
            } else {
                const inputs = document.querySelectorAll('.indiv-amount');
                    for (const inp of inputs) {
                    const val = parseFloat(inp.value) || 0;
                    if (val > 0) {
                        totalAmount += val;
                            const { data: player } = await supabase
                                .from('table_players')
                                .select('food_debt')
                                .eq('id', inp.dataset.id)
                                .single();
                            
                            await supabase
                                .from('table_players')
                                .update({ food_debt: (player.food_debt || 0) + val })
                                .eq('id', inp.dataset.id);
                        }
                    }
                if(totalAmount === 0) return alert('×œ× ×”×•×–× ×• ×¡×›×•××™×');
            }

            // Credit the payer
                const { data: payer } = await supabase
                    .from('table_players')
                    .select('food_credit')
                    .eq('id', payerId)
                    .single();

                await supabase
                    .from('table_players')
                    .update({ food_credit: (payer.food_credit || 0) + totalAmount })
                    .eq('id', payerId);
                
            closeModal('modal-food');
            alert('× ×©××¨! ×”××©×œ× ×–×•×›×”, ×”×¡×•×¢×“×™× ×—×•×™×‘×•.');
            } catch (error) {
                alert('×©×’×™××” ×‘×©××™×¨×ª ×”×•×¦××”: ' + error.message);
            }
        }

        // --- SETTLEMENT & LEAGUE ---
        async function startSettle() {
            try {
                const { data: players } = await supabase
                    .from('table_players')
                    .select('*, profiles(username, phone_number)')
                    .eq('table_id', activeTableId);

            const container = document.getElementById('settleInputs');
            container.innerHTML = '';
            
                players?.forEach(p => {
                container.innerHTML += `
                    <div style="margin-bottom:10px;">
                            <label>${p.profiles?.username || '×©×—×§×Ÿ'}</label>
                        <input type="number" class="cashout-input" data-id="${p.id}" placeholder="×›×¡×£ ×‘×™×“">
                    </div>`;
            });

            hideAllViews();
            document.getElementById('view-settle').classList.remove('hidden');
            document.getElementById('backBtn').style.visibility = 'visible';
            document.getElementById('settleResults').classList.add('hidden');
            document.getElementById('btnFinishGame').classList.add('hidden');
            } catch (error) {
                console.error('Error starting settle:', error);
            }
        }

        async function calcResult() {
            try {
                // Validate activeTableId
                if (!activeTableId || 
                    activeTableId === null || 
                    activeTableId === 'null' || 
                    typeof activeTableId !== 'string' ||
                    !UUID_REGEX.test(activeTableId)) {
                    console.error('âŒ Invalid active table ID in calcResult:', activeTableId);
                    alert('×©×’×™××”: ×©×•×œ×—×Ÿ ×œ× ×ª×§×™×Ÿ. × × ×œ×—×–×•×¨ ×œ×œ×•×‘×™ ×•×œ×¤×ª×•×— ×©×•×œ×—×Ÿ ××—×“×©.');
                    return;
                }

                const { data: table } = await supabase
                    .from('tables')
                    .select('buy_in')
                    .eq('id', activeTableId)
                    .single();

                const { data: players, error: playersError } = await supabase
                    .from('table_players')
                    .select('id, user_id, rebuys, food_credit, food_debt, profiles(username, phone_number)')
                    .eq('table_id', activeTableId);
                
                if (playersError) {
                    console.error('âŒ Error fetching players:', playersError);
                    throw playersError;
                }
                
                console.log('ğŸ“Š Players data from DB:', players);

            const inputs = document.querySelectorAll('.cashout-input');
            let tempPlayers = [];

            console.log('=== STARTING CALCULATION ===');
            console.log(`Found ${inputs.length} input fields`);

            inputs.forEach(inp => {
                    const playerId = inp.dataset.id;
                const cash = parseFloat(inp.value) || 0;
                    const p = players.find(x => x.id === playerId);
                    
                    if (!p) {
                        console.error(`âŒ Player with ID ${playerId} not found in database!`);
                        return;
                    }
                    
                    const invested = (p.rebuys || 1) * table.buy_in;
                    const foodCredit = p.food_credit || 0;
                    const foodDebt = p.food_debt || 0;
                    const foodBalance = foodCredit - foodDebt;
                    const net = (cash - invested) + foodBalance;
                    
                    console.log(`\nğŸ’° Calculating for "${p.profiles?.username || 'Unknown'}":`);
                    console.log(`   ğŸ“¥ Input value (raw): "${inp.value}"`);
                    console.log(`   ğŸ“¥ Cash out: ${cash}â‚ª`);
                    console.log(`   ğŸ° Rebuys: ${p.rebuys || 1}`);
                    console.log(`   ğŸ’µ Buy-in: ${table.buy_in}â‚ª`);
                    console.log(`   ğŸ’¸ Total invested: ${invested}â‚ª`);
                    console.log(`   ğŸ• Food credit: ${foodCredit}â‚ª`);
                    console.log(`   ğŸ” Food debt: ${foodDebt}â‚ª`);
                    console.log(`   ğŸ½ï¸ Food balance: ${foodBalance}â‚ª`);
                    console.log(`   ğŸ“Š Net profit calculation: (${cash} - ${invested}) + ${foodBalance} = ${net}â‚ª`);
                    console.log(`   ğŸ” net value: ${net}, type: ${typeof net}, isNaN: ${isNaN(net)}`);
                    
                    // CRITICAL FIX: Get the actual user_id from the database row
                    // Make sure null values are NOT converted to string "null"
                    const actualUserId = p.user_id;
                    const isValidUUID = actualUserId && actualUserId !== null && typeof actualUserId === 'string' && actualUserId !== 'null';
                    
                    console.log(`ğŸ‘¤ Player: "${p.profiles?.username || 'Unknown'}":`);
                    console.log(`   - user_id: "${actualUserId}"`);
                    console.log(`   - type: ${typeof actualUserId}`);
                    console.log(`   - is null: ${actualUserId === null}`);
                    console.log(`   - is "null": ${actualUserId === 'null'}`);
                    console.log(`   - is valid UUID: ${isValidUUID}`);
                    console.log(`   - net profit: ${net}â‚ª`);
                    
                    // Create player object with explicit net value
                    const playerObj = {
                        id: playerId, // table_players id
                        userId: actualUserId, // ACTUAL user UUID from DB (or null)
                        name: p.profiles?.username || t('player'),
                        phone: p.profiles?.phone_number || null,
                        cash_out: cash, // Save the cash out amount!
                        net: net // Explicitly set net value
                    };
                    
                    console.log(`   âœ… Player object created with net: ${playerObj.net}â‚ª`);
                    console.log(`   ğŸ” playerObj.net value: ${playerObj.net}, type: ${typeof playerObj.net}`);
                    
                    tempPlayers.push(playerObj);
                    
                    console.log(`   âœ… Player added to tempPlayers. Last player net: ${tempPlayers[tempPlayers.length - 1].net}â‚ª`);
            });

            // Validate Sum (logging only, no blocking)
            const total = tempPlayers.reduce((sum, p) => sum + p.net, 0);
            console.log('Calculated total balance:', total);
            console.log('All players data:', tempPlayers);
            
            // Just log if there's a discrepancy, don't block
            if (Math.abs(total) > 0.5) {
                console.warn(`âš ï¸ Balance discrepancy: ${Math.round(total)}â‚ª`);
            }

                // Display Logic with Pay with Bit buttons
            // CRITICAL FIX: Create copies of players for transfer calculation
            // This prevents modifying the original net values in tempPlayers
            let debtors = tempPlayers
                .filter(p => p.net < -0.5)
                .map(p => ({ ...p, net: p.net })) // Create copy with net value
                .sort((a,b) => a.net - b.net);
            let creditors = tempPlayers
                .filter(p => p.net > 0.5)
                .map(p => ({ ...p, net: p.net })) // Create copy with net value
                .sort((a,b) => b.net - a.net);
            let transfers = [];

            let d=0, c=0;
            while(d < debtors.length && c < creditors.length) {
                let amount = Math.min(Math.abs(debtors[d].net), creditors[c].net);
                    const creditorPhone = creditors[c].phone;
                    const creditorName = creditors[c].name;
                    const debtorName = debtors[d].name;
                    
                    let transferHtml = `
                        <div class="transfer-row">
                            <div class="transfer-info">
                                <b>${debtorName}</b> ${t('transfers')} <b>${Math.round(amount)}â‚ª</b> ${t('to')} <b>${creditorName}</b>
                            </div>
                    `;
                    
                    // Add Pay with Bit button if phone number exists
                    if (creditorPhone) {
                        // Escape single quotes in names/phone for onclick
                        const safePhone = creditorPhone.replace(/'/g, "\\'");
                        const safeName = creditorName.replace(/'/g, "\\'");
                        transferHtml += `
                            <button class="btn-bit" onclick="payWithBit('${safePhone}', '${safeName}', ${amount})">
                                ğŸ’³ ${t('payWithBit')}
                            </button>
                        `;
                    }
                    
                    transferHtml += '</div>';
                    transfers.push(transferHtml);
                
                // Now it's safe to modify net - we're working with copies
                debtors[d].net += amount;
                creditors[c].net -= amount;
                
                if(Math.abs(debtors[d].net) < 0.5) d++;
                if(creditors[c].net < 0.5) c++;
            }

            const resDiv = document.getElementById('settleResults');
            resDiv.classList.remove('hidden');
            resDiv.innerHTML = `<h3 style="color:var(--gold); margin-top:0;">${t('transfersToMake')}</h3>` + 
                                   (transfers.length ? transfers.join('') : `<div style="text-align:center; padding:20px;">${t('allBalanced')}</div>`);
            
                // Store results for saving
                console.log('\nğŸ’¾ Storing tempSettleResults:');
                tempPlayers.forEach((p, idx) => {
                    console.log(`  Player ${idx + 1}: ${p.name}`);
                    console.log(`    - id: ${p.id}`);
                    console.log(`    - userId: ${p.userId}`);
                    console.log(`    - cash_out: ${p.cash_out}â‚ª`);
                    console.log(`    - net: ${p.net}â‚ª`);
                    console.log(`    - net type: ${typeof p.net}`);
                });
                window.tempSettleResults = tempPlayers;
                console.log('âœ… tempSettleResults stored:', window.tempSettleResults);
            document.getElementById('btnFinishGame').classList.remove('hidden');
            } catch (error) {
                console.error('Error calculating results:', error);
                alert('×©×’×™××” ×‘×—×™×©×•×‘ ×ª×•×¦××•×ª');
            }
        }

        // --- PAY WITH BIT ---
        /**
         * Sanitizes a phone number by removing dashes, spaces, and international codes
         * @param {string} phoneNumber - The phone number to sanitize
         * @returns {string} - Clean phone number (e.g., "0501234567")
         */
        function sanitizePhoneNumber(phoneNumber) {
            if (!phoneNumber) return null;
            
            // Remove all non-digit characters (dashes, spaces, parentheses, etc.)
            let cleaned = phoneNumber.replace(/\D/g, '');
            
            // Remove international prefix if present (e.g., 972, +972)
            if (cleaned.startsWith('972')) {
                cleaned = '0' + cleaned.substring(3);
            }
            
            // Ensure it starts with 0 and has 10 digits
            if (cleaned.length === 9 && !cleaned.startsWith('0')) {
                cleaned = '0' + cleaned;
            }
            
            // Return only if it's a valid 10-digit Israeli phone number
            if (cleaned.length === 10 && cleaned.startsWith('0')) {
                return cleaned;
            }
            
            return cleaned; // Return as-is if doesn't match expected format
        }

        /**
         * Opens Bit payment app with the recipient's phone number and amount
         * @param {string} phoneNumber - Recipient's phone number
         * @param {string} creditorName - Recipient's name (for display)
         * @param {number} amount - Amount to pay in NIS
         */
        async function payWithBit(phoneNumber, creditorName, amount) {
            try {
                // Sanitize phone number
                const cleanPhone = sanitizePhoneNumber(phoneNumber);

                if (!cleanPhone) {
                    showToast('××¡×¤×¨ ×˜×œ×¤×•×Ÿ ×œ× ×ª×§×™×Ÿ');
                    return;
                }

                const roundedAmount = Math.round(amount);

                // Copy payment details to clipboard
                const paymentInfo = `${creditorName}: ${cleanPhone} - ${roundedAmount}â‚ª`;
                try {
                    await navigator.clipboard.writeText(paymentInfo);
                } catch (e) {
                    console.log('Clipboard not available');
                }

                // Detect if mobile
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

                // Try different Bit deep link formats
                if (isMobile) {
                    // On mobile, try app scheme first
                    const appLink = `bit://pay?phone=${cleanPhone}&amount=${roundedAmount}`;
                    window.location.href = appLink;

                    // Fallback to web if app doesn't open
                    setTimeout(() => {
                        window.open(`https://www.bitpay.co.il/app/`, '_blank');
                    }, 1500);

                    showToast(`×¤×•×ª×— Bit... ${creditorName}: ${roundedAmount}â‚ª`);
                } else {
                    // On desktop, open web version and show manual entry instructions
                    window.open('https://www.bitpay.co.il/app/', '_blank');

                    // Show payment details in a user-friendly way
                    setTimeout(() => {
                        const message = currentLanguage === 'he'
                            ? `×¤×¨×˜×™ ×”×ª×©×œ×•×:\n\nğŸ‘¤ ${creditorName}\nğŸ“± ${cleanPhone}\nğŸ’° ${roundedAmount}â‚ª\n\n(×”×¤×¨×˜×™× ×”×•×¢×ª×§×• ×œ×œ×•×—)`
                            : `Payment details:\n\nğŸ‘¤ ${creditorName}\nğŸ“± ${cleanPhone}\nğŸ’° ${roundedAmount}â‚ª\n\n(Details copied to clipboard)`;
                        alert(message);
                    }, 500);
                }

            } catch (error) {
                console.error('Error with Bit payment:', error);
                // Ultimate fallback
                window.open('https://www.bitpay.co.il/app/', '_blank');
                showToast('×¤×•×ª×— Bit - ×”×–×Ÿ ×¤×¨×˜×™× ×™×“× ×™×ª');
            }
        }

        async function saveAndExit() {
            try {
                if (!window.tempSettleResults) {
                    alert(t('noDataToSave'));
                    return;
                }

                // Validate activeTableId - must be a valid UUID
                if (!activeTableId || 
                    activeTableId === null || 
                    activeTableId === 'null' || 
                    activeTableId === 'undefined' ||
                    typeof activeTableId !== 'string' ||
                    !UUID_REGEX.test(activeTableId)) {
                    console.error('âŒ Invalid active table ID in saveAndExit:', activeTableId);
                    alert('×©×’×™××”: ×©×•×œ×—×Ÿ ×œ× ×ª×§×™×Ÿ. × × ×œ×—×–×•×¨ ×œ×œ×•×‘×™ ×•×œ×¤×ª×•×— ×©×•×œ×—×Ÿ ××—×“×©.');
                    return;
                }

                console.log('=== STARTING SAVE AND EXIT ===');
                console.log('âœ… Valid Active Table ID:', activeTableId);
                console.log('\nğŸ“‹ All players to save (raw):', window.tempSettleResults);
                if (window.tempSettleResults) {
                    window.tempSettleResults.forEach((p, idx) => {
                        console.log(`  Player ${idx + 1}: ${p.name}`);
                        console.log(`    - id: ${p.id}`);
                        console.log(`    - userId: ${p.userId}`);
                        console.log(`    - cash_out: ${p.cash_out}â‚ª`);
                        console.log(`    - net: ${p.net}â‚ª`);
                        console.log(`    - net type: ${typeof p.net}`);
                        console.log(`    - net === 0: ${p.net === 0}`);
                        console.log(`    - net === '0': ${p.net === '0'}`);
                    });
                }

                // 1. Update table_players with results (Cash Out & Net Profit)
                // This works for ALL players
                console.log('Step 1: Updating table_players...');
                console.log('Data from tempSettleResults:', window.tempSettleResults);
                
                const updates = window.tempSettleResults.map(p => ({
                    id: p.id, // table_players id
                    cash_out: p.cash_out || 0, // Use the saved cash_out value
                    net_profit: p.net
                }));
                
                console.log('Updates to apply:', updates);

                // Perform updates in parallel
                const updateResults = await Promise.all(updates.map(u => 
                    supabase.from('table_players')
                        .update({ cash_out: u.cash_out, net_profit: u.net_profit })
                        .eq('id', u.id)
                ));

                // Check for errors in updates
                const updateErrors = updateResults.filter(r => r.error);
                if (updateErrors.length > 0) {
                    console.error('Errors updating table_players:', updateErrors);
                    // We continue anyway to try and save game history
                }

                console.log('Step 1 complete: table_players updated');

                // 2. Save to game_results (This triggers user stats update via trigger)
                console.log('Step 2: Filtering valid users for game_results...');
                
                // First, log ALL players to see what we have
                console.log('ğŸ” ALL players in tempSettleResults:');
                window.tempSettleResults.forEach((p, idx) => {
                    console.log(`  Player ${idx + 1}: "${p.name}"`);
                    console.log(`    - userId: ${p.userId}`);
                    console.log(`    - userId type: ${typeof p.userId}`);
                    console.log(`    - userId === null: ${p.userId === null}`);
                    console.log(`    - userId === undefined: ${p.userId === undefined}`);
                    console.log(`    - userId === 'null': ${p.userId === 'null'}`);
                });

                const validResults = window.tempSettleResults.filter(p => {
                    const userId = p.userId;
                    
                    // Check for all possible invalid states
                    if (userId === null || userId === undefined) {
                        console.warn(`âŒ Skipping player "${p.name}" - userId is null/undefined`);
                        return false;
                    }
                    
                    if (typeof userId !== 'string') {
                        console.warn(`âŒ Skipping player "${p.name}" - userId is not a string (type: ${typeof userId})`);
                        return false;
                    }
                    
                    if (userId === 'null' || userId === 'undefined' || userId.trim() === '') {
                        console.warn(`âŒ Skipping player "${p.name}" - userId is invalid string: "${userId}"`);
                        return false;
                    }
                    
                    if (!UUID_REGEX.test(userId)) {
                        console.warn(`âŒ Skipping player "${p.name}" - userId is not a valid UUID: "${userId}"`);
                        return false;
                    }
                    
                    console.log(`âœ… Player "${p.name}" has valid UUID: ${userId}`);
                    return true;
                });
                
                console.log(`Found ${validResults.length} valid registered users out of ${window.tempSettleResults.length} total players`);

                // Additional safety check: Verify all players in table_players have valid user_ids
                console.log('\nğŸ” Double-checking table_players in database...');
                const { data: dbPlayers, error: dbCheckError } = await supabase
                    .from('table_players')
                    .select('id, user_id')
                    .eq('table_id', activeTableId);
                
                if (dbCheckError) {
                    console.error('âŒ Error checking table_players:', dbCheckError);
                } else {
                    const playersWithNull = dbPlayers.filter(p => !p.user_id || p.user_id === null);
                    if (playersWithNull.length > 0) {
                        console.warn(`âš ï¸ WARNING: Found ${playersWithNull.length} players in database with NULL user_id!`);
                        console.warn('These players will be skipped when saving game results.');
                        console.warn('Player IDs with NULL user_id:', playersWithNull.map(p => p.id));
                    } else {
                        console.log('âœ… All players in database have valid user_id');
                    }
                }

                if (validResults.length > 0) {
                    console.log('\n=== PREPARING DATA FOR GAME_RESULTS INSERT ===');
                    validResults.forEach((p, index) => {
                        console.log(`Player ${index + 1}: ${p.name}`);
                        console.log(`  - user_id: ${p.userId}`);
                        console.log(`  - net_profit: ${p.net}â‚ª`);
                    });
                    
                    // Final safety check: Remove any results with invalid user_id (double-check)
                    const finalValidResults = validResults.filter(p => {
                        const userId = p.userId;
                        if (!userId || userId === null || userId === undefined || 
                            userId === 'null' || userId === 'undefined' || 
                            typeof userId !== 'string' || !UUID_REGEX.test(userId)) {
                            console.error(`ğŸš¨ CRITICAL: Found invalid userId in final check: "${userId}" for player "${p.name}"`);
                            return false;
                        }
                        return true;
                    });

                    if (finalValidResults.length !== validResults.length) {
                        console.error(`ğŸš¨ WARNING: Filtered out ${validResults.length - finalValidResults.length} invalid results in final check!`);
                    }

                    if (finalValidResults.length === 0) {
                        console.error('âŒ No valid results to insert after final check!');
                        alert('×©×’×™××”: ××™×Ÿ ×©×—×§× ×™× ×ª×§×™× ×™× ×œ×©××™×¨×”. ×•×•×“× ×©×›×œ ×”×©×—×§× ×™× ×¨×©×•××™× ×‘××¢×¨×›×ª.');
                        return;
                    }

                    const resultsToInsert = finalValidResults.map(p => {
                        // Triple-check the user_id before inserting
                        if (!p.userId || p.userId === 'null' || !UUID_REGEX.test(p.userId)) {
                            throw new Error(`Invalid user_id detected: "${p.userId}" for player "${p.name}"`);
                        }
                        return {
                            table_id: activeTableId,
                            user_id: p.userId,
                            net_profit: p.net,
                            game_date: new Date().toISOString()
                        };
                    });

                    console.log('\nğŸ“¤ Final data to insert into game_results (after triple-check):');
                    console.log(JSON.stringify(resultsToInsert, null, 2));
                    
                    const { data: insertedData, error: resultsError } = await supabase
                        .from('game_results')
                        .insert(resultsToInsert)
                        .select();

                    if (resultsError) {
                        console.error('âŒ Error inserting game results:', resultsError);
                        alert('×©×’×™××” ×‘×©××™×¨×ª ×”×™×¡×˜×•×¨×™×”: ' + resultsError.message + '\n×”× ×ª×•× ×™× ×‘×©×•×œ×—×Ÿ × ×©××¨×•, ××‘×œ ×”×¡×˜×˜×™×¡×˜×™×§×•×ª ×œ× ×¢×•×“×›× ×•.');
                    } else {
                        console.log('âœ… Game results inserted successfully:', insertedData);
                        alert('×”× ×ª×•× ×™× × ×©××¨×• ×‘×”×¦×œ×—×”! ×”×¤×¨×•×¤×™×œ×™× ×¢×•×“×›× ×•.');
                    }
                } else {
                    console.warn('âš ï¸ No valid users to save to history');
                    alert('×”× ×ª×•× ×™× × ×©××¨×• ×‘×©×•×œ×—×Ÿ. (×œ× ×”×™×• ××©×ª××©×™× ×¨×©×•××™× ×ª×§×™× ×™× ×œ×¢×“×›×•×Ÿ ×¤×¨×•×¤×™×œ)');
                }

                console.log('Step 2 complete');
                
                // Clear local state
                window.tempSettleResults = null;
                
                // Close realtime subscriptions before clearing activeTableId
                if (activeTableId && realtimeChannels[activeTableId]) {
                    console.log('ğŸ”’ Closing realtime subscription for table:', activeTableId);
                    realtimeChannels[activeTableId].unsubscribe();
                    delete realtimeChannels[activeTableId];
                }
                
                // Step 3: Reset session data for next round (Persistent Club Model)
                // Reset only session-specific data, preserve Hall of Fame (game_results)
                console.log('Step 3: Resetting session data for next round...');
                const { data: allPlayers, error: fetchPlayersError } = await supabase
                    .from('table_players')
                    .select('id')
                    .eq('table_id', activeTableId);
                
                if (fetchPlayersError) {
                    console.error('âŒ Error fetching players for reset:', fetchPlayersError);
                } else if (allPlayers && allPlayers.length > 0) {
                    // Reset all session-specific fields to defaults for next session
                    const resetUpdates = allPlayers.map(p => ({
                        id: p.id,
                        cash_out: 0,
                        net_profit: 0,
                        rebuys: 1,
                        food_credit: 0,
                        food_debt: 0
                    }));
                    
                    console.log(`Resetting ${resetUpdates.length} players for next session...`);
                    
                    // Perform resets in parallel
                    const resetResults = await Promise.all(resetUpdates.map(u => 
                        supabase.from('table_players')
                            .update({ 
                                cash_out: u.cash_out, 
                                net_profit: u.net_profit,
                                rebuys: u.rebuys,
                                food_credit: u.food_credit,
                                food_debt: u.food_debt
                            })
                            .eq('id', u.id)
                    ));
                    
                    const resetErrors = resetResults.filter(r => r.error);
                    if (resetErrors.length > 0) {
                        console.error('âš ï¸ Some errors resetting session data:', resetErrors);
                        // Non-critical, continue anyway
                    } else {
                        console.log('âœ… Session data reset successfully - table ready for next round');
                    }
                } else {
                    console.log('â„¹ï¸ No players to reset');
                }
                
                // IMPORTANT: Keep table active (is_active: true) so it remains visible in lobby
                // This implements the "Persistent Club" model - table stays accessible
                // Hall of Fame data is preserved in game_results table
                console.log('Step 4: Ensuring table remains active (Persistent Club Model)...');
                const { data: tableUpdateData, error: ensureActiveError } = await supabase
                    .from('tables')
                    .update({ is_active: true })
                    .eq('id', activeTableId)
                    .select();
                
                if (ensureActiveError) {
                    console.error('âŒ CRITICAL: Could not ensure table is active:', ensureActiveError);
                    alert('×©×’×™××”: ×œ× × ×™×ª×Ÿ ×œ×©××•×¨ ××ª ×”×©×•×œ×—×Ÿ ×¤×¢×™×œ. ×”×©×•×œ×—×Ÿ ×¢×œ×•×œ ×œ×”×™×¢×œ× ××”×œ×•×‘×™.');
                } else {
                    console.log('âœ… Table confirmed active - will remain visible in lobby with all Hall of Fame stats');
                    console.log('Updated table data:', tableUpdateData);
                }

                // Exit to Lobby
                console.log('Exiting to lobby...');
                clearTableFromURL();
                activeTableId = null;
                
                // Small delay to ensure database update is complete before showing lobby
                await new Promise(resolve => setTimeout(resolve, 100));
                
                showLobby();
                
            } catch (error) {
                console.error('=== ERROR IN SAVE AND EXIT ===');
                console.error(error);
                alert('×©×’×™××” ×§×¨×™×˜×™×ª ×‘×©××™×¨×”: ' + error.message);
            }
        }

        function showGameSummary(results) {
            hideAllViews();
            document.getElementById('view-summary').classList.remove('hidden');
            document.getElementById('backBtn').style.visibility = 'hidden';
            
            document.getElementById('summaryTableName').textContent = document.getElementById('activeTableName').innerText;
            
            const list = document.getElementById('summaryList');
            list.innerHTML = '';
            
            // Sort by profit (highest first)
            const sorted = [...results].sort((a, b) => b.net - a.net);
            
            sorted.forEach((p, index) => {
                const isWinner = p.net > 0;
                const color = isWinner ? 'var(--green)' : (p.net < 0 ? 'var(--red)' : 'var(--gray)');
                const sign = p.net > 0 ? '+' : '';
                const icon = index === 0 ? 'ğŸ‘‘' : (index === sorted.length - 1 ? 'ğŸ’€' : 'ğŸ‘¤');
                
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.justifyContent = 'space-between';
                row.style.padding = '10px';
                row.style.borderBottom = '1px solid #333';
                row.style.fontSize = '1.1rem';
                
                row.innerHTML = `
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span>${icon}</span>
                        <span>${p.name}</span>
                    </div>
                    <div style="font-weight:bold; color:${color}; direction:ltr; text-align:right;">
                        ${sign}${Math.round(p.net)}â‚ª
                    </div>
                `;
                list.appendChild(row);
            });
            
            // Clear URL (game is over)
            clearTableFromURL();
            activeTableId = null;
        }

        // --- SHARE ---
        async function openShareModal() {
            const baseUrl = window.location.origin + window.location.pathname;
            const joinUrl = `${baseUrl}?joinTable=${activeTableId}`;
            document.getElementById('shareLink').value = joinUrl;
            document.getElementById('qrImage').src = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(joinUrl)}`;
            openModal('modal-share');
        }

        async function copyShareLink() {
            const shareLinkInput = document.getElementById('shareLink');
            const link = shareLinkInput.value;
            
            if (!link) {
                showToast('××™×Ÿ ×§×™×©×•×¨ ×œ×”×¢×ª×§×”');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(link);
                showToast('×”×§×™×©×•×¨ ×”×•×¢×ª×§!');
            } catch (error) {
                console.error('Error copying link:', error);
                // Fallback: select text
                shareLinkInput.select();
                shareLinkInput.setSelectionRange(0, 99999); // For mobile devices
                try {
                    document.execCommand('copy');
                    showToast('×”×§×™×©×•×¨ ×”×•×¢×ª×§!');
                } catch (err) {
                    showToast('×©×’×™××” ×‘×”×¢×ª×§×”. × ×¡×” ×œ×‘×—×•×¨ ××ª ×”×˜×§×¡×˜ ×™×“× ×™×ª.');
                }
            }
        }

        // --- HELPERS ---
        function openModal(id) { document.getElementById(id).classList.remove('hidden'); }
        function closeModal(id) { document.getElementById(id).classList.add('hidden'); }

        // --- INIT ---
        // Initialize language first
        initLanguage();
        
        // Then check authentication
        checkAuth();

        // Listen for auth changes
        supabase.auth.onAuthStateChange((event, session) => {
            console.log('ğŸ” Auth state change:', event);
            
            if (event === 'SIGNED_IN' && session) {
                currentUser = session.user;
                // Don't redirect if we are in the middle of initial loading
                // or if checkAuth is handling a specific table URL
                if (!isLoading) {
                    loadProfile().then(() => {
                        const tableId = getTableIdFromURL();
                        if (!tableId) {
                            handleJoinFlow();
        showLobby();
                        } else {
                            console.log('Skipping lobby redirect in onAuthStateChange because tableId exists');
                        }
                    });
                }
            } else if (event === 'SIGNED_OUT') {
                currentUser = null;
                currentProfile = null;
                showAuth();
            }
        });

    </script>
</body>
</html>
